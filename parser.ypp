%{
#include <iostream>
#include "llvm.h"
#include "parser.hpp"
#include "hw3_output.hpp"
#include "bp.hpp"
#include <climits>
extern int yylineno;
using namespace std;
int yyerror(const char * const s);
int yylex(void);
Stacks* semantic_stacks;
#define YYDEBUG 1
#pragma GCC diagnostic ignored "-Wfree-nonheap-object"
#define gen_code (CodeBuffer::instance())

TokenType convert_table[5][5]={
        {/*UNDIF TO*/
                /*TOKEN_UNDIF*/TOKEN_UNDIF,
                /*TOKEN_INT*/TOKEN_UNDIF,
                /*TOKEN_B*/TOKEN_UNDIF,
                /*TOKEN_BOOL*/TOKEN_UNDIF,
                /*TOKEN_STRING*/TOKEN_UNDIF
        },
        {/*INT TO*/
                /*TOKEN_UNDIF*/TOKEN_UNDIF,
                /*TOKEN_INT*/TOKEN_INT,
                /*TOKEN_B*/TOKEN_INT,
                /*TOKEN_BOOL*/TOKEN_UNDIF,/*not sure*/
                /*TOKEN_STRING*/TOKEN_UNDIF
        },
        {/*B TO*/
                /*TOKEN_UNDIF*/TOKEN_UNDIF,
                /*TOKEN_INT*/TOKEN_INT,
                /*TOKEN_B*/TOKEN_B,
                /*TOKEN_BOOL*/TOKEN_UNDIF,
                /*TOKEN_STRING*/TOKEN_UNDIF
        },
        {/*BOOL TO*/
                /*TOKEN_UNDIF*/TOKEN_UNDIF,
                /*TOKEN_INT*/TOKEN_UNDIF,
                /*TOKEN_B*/TOKEN_UNDIF,
                /*TOKEN_BOOL*/TOKEN_BOOL,
                /*TOKEN_STRING*/TOKEN_UNDIF
        },
        {/*STRING TO*/
                /*TOKEN_UNDIF*/TOKEN_UNDIF,
                /*TOKEN_INT*/TOKEN_UNDIF,
                /*TOKEN_B*/TOKEN_UNDIF,
                /*TOKEN_BOOL*/TOKEN_UNDIF,
                /*TOKEN_STRING*/TOKEN_STRING
        }
};


%}

%token VOID INT BYTE B BOOL TRUE FALSE RETURN WHILE BREAK CONTINUE SC COMMA LBRACE RBRACE ID NUM STRING
%right ASSIGN
%left OR
%left AND
%nonassoc RELOP
%left PLUS
%left MULTI
%right NOT
%right RPAREN
%right LPAREN

%nonassoc NOELSE
%nonassoc ELSE

%nonassoc IF

%nonassoc CAST
%token YYEOF
%%

Program:   
		{ semantic_stacks=new Stacks();}
		Funcs YYEOF {
			if(!semantic_stacks->is_exsists("main") || !semantic_stacks->is_func("main") || semantic_stacks->get_type("main") != TokenType::TOKEN_UNDIF || semantic_stacks->get_args("main")->size()!=0)
			{
				output::errorMainMissing();
				exit(2);
			}
		 //semantic_stacks->exit_scope();
		  }
		;

Funcs: 
	%empty  
	| FuncDecl Funcs {}
		;

FuncDecl: 
		RetType ID LPAREN Formals RPAREN  {
			if(semantic_stacks->is_exsists($2->name))
			{
				output::errorDef(yylineno,$2->name);
				exit(2);
			}

			for(int i=0; i<$4->get_args()->size();i++)
			{
				if($4->get_args()->at(i).second == $2->name)
				{
					output::errorDef(yylineno,$2->name);
					exit(2);
				}
			}

			semantic_stacks->new_func($2->name,$1->type,$4->get_args());
			string type_in_str = $1->type==TokenType::TOKEN_UNDIF ? "void" : "i32";
            string args = "";
            for (auto i = 0; i < $4->get_args()->size(); i++)
            {
                args = args + "i32 ,";
            }
            args = args.substr(0, args.length() - 1);
			gen_code.emit("define " + type_in_str + " @" + $2->name + "(" + args + ") {");
			gen_code.emit("entry:");
			gen_code.emit("%fp = alloca [50 x i32]");
		}
            LBRACE Statements RBRACE {
            semantic_stacks->exit_scope();gen_code.emit("}");
             }
		;

RetType:		
		Type { $$ = $1; }
		| VOID { $$ = new Node(TokenType::TOKEN_UNDIF,"",0); }
		;

Formals:		
		%empty { $$ = new FormalList(); }
		| FormalsList { $$ = $1; }
		;
FormalsList:	
			FormalDecl {if(semantic_stacks->is_exsists($1->name)){output::errorDef(yylineno,$1->name); exit(2);}$$ = new FormalList(); $$->get_args()->insert($$->get_args()->begin(),pair<TokenType,string>($1->type,$1->name));}
			| FormalDecl COMMA FormalsList 
			{
				vector<pair<TokenType,string>>* args = $3->get_args();
				for(int i=0;i<args->size();i++)
					if(args->at(i).second == $1->name)
					{
						output::errorDef(yylineno,$1->name);
						exit(2);
					}
				if(semantic_stacks->is_exsists($1->name))
				{
					output::errorDef(yylineno,$1->name);
					exit(2);
				}
				$3->get_args()->insert($3->get_args()->begin(),pair<TokenType,string>($1->type,$1->name));
				$$ = $3;
			}
			;

FormalDecl: 	
			Type ID { $$ = new Node($1->type,$2->name,0); }
		;
Statements:	
			Statement {
			$$=new Node();
			$$->next_list = $1->next_list;
                  $$->break_list = $1->break_list;
                  $$->continue_list = $1->continue_list;
            }
			| Statements M Statement
			{
                if ($3->return_statement == false)
                {
                    gen_code.bpatch($1->next_list, $2->quad);
                }
                $$=new Node();
                $$->next_list = $3->next_list;
                $$->break_list = gen_code.merge($1->break_list,$3->break_list);
                $$->continue_list = gen_code.merge($1->continue_list,$3->continue_list);
            }
		;

M:
    %empty                            
	{
          int buffer_index = gen_code.emit("br label @");
          string label = gen_code.genLabel();
          gen_code.bpatch(gen_code.makelist({buffer_index, FIRST}), label);
          $$=new Node();
          $$->quad = label;
    };

N:
    %empty                            
	{
          int buffer_index = gen_code.emit("br label @");
          string label = gen_code.genLabel();
          gen_code.bpatch(gen_code.makelist({buffer_index, FIRST}), label);
          $$=new Node();
          $$->quad = label;
       $$->next_list = gen_code.makelist({gen_code.emit("br label @"), FIRST});
    };

Statement:	
		LBRACE {

		    semantic_stacks->new_scope();
		}
		Statements M RBRACE
		{
             $$ = new Node();
             $$->next_list = $3->next_list;
             $$->break_list = $3->break_list;
             $$->continue_list = $3->continue_list;
             gen_code.bpatch($3->next_list,$4->quad);
            semantic_stacks->exit_scope();
		}

		| Type ID SC {
			if(semantic_stacks->is_exsists($2->name))
			{
				output::errorDef(yylineno,$2->name);
				exit(2);
			}
			$$ = new Node($1->type, $2->name, 0);
			semantic_stacks->new_entry($2->name,$1->type,0);
			string name = "%var"+ to_string(gen_code.current_var++);
            gen_code.emit("store i32 0 , i32* "+name);
            gen_code.emit(name + " = getelementptr [50 x i32], [50 x i32]* %fp, i32 0 , i32 " + to_string(semantic_stacks->get_entry($2->name)->offset));
		}
		| Type ID ASSIGN Exp SC {
			if(semantic_stacks->is_exsists($2->name))
			{
				output::errorDef(yylineno,$2->name);
				exit(2);
			}

			if(convert_table[$1->type][$4->type] == false || ($1->type == TokenType::TOKEN_B && $4->type == TokenType::TOKEN_INT))
			{
			printf("here2");
			fflush(stdout);
				output::errorMismatch(yylineno);
				exit(2);
			}
			
			if($2->type == TokenType::TOKEN_B && $4->value > 255)
			{
				output::errorByteTooLarge(yylineno, std::to_string($3->value));
				exit(2);
			}
			
			$$ = new Node($1->type,$2->name,$4->value);
			semantic_stacks->new_entry($2->name,$1->type,$4->value);

			string place = $4->place== ""? to_string($4->value) : $4->place;


            if ($1->type != TokenType::TOKEN_BOOL)
            {
                string target = "%var"+to_string(gen_code.current_var++);
                string name = "%var"+ to_string(gen_code.current_var++);
                gen_code.emit(name + " = getelementptr [50 x i32], [50 x i32]* %fp, i32 0 , i32 " + to_string(semantic_stacks->get_entry($2->name)->offset));
                gen_code.emit("store i32 " + to_string($4->value) + " , i32* "+name);
                 $$->next_list = $4->next_list;
            }
            else
            {
               string true_temp = "%var"+ to_string(gen_code.current_var++);
               string false_temp = "%var"+ to_string(gen_code.current_var++);

               int unused_index = gen_code.emit("br label @");
               string true_label = gen_code.genLabel();
               gen_code.bpatch(gen_code.makelist({unused_index, FIRST}), true_label);

               gen_code.emit(declare_var_llvm(true_temp, "0", semantic_stacks->get_entry($2->name)->offset));
               gen_code.emit("store i32 1 , i32* " + true_temp);

               int true_index_patch = gen_code.emit("br label @");
               gen_code.bpatch($4->true_list, true_label);

               string false_label = gen_code.genLabel();
               gen_code.emit(declare_var_llvm(false_temp, "0", semantic_stacks->get_entry($2->name)->offset));
               gen_code.emit("store i32 0 , i32* " + true_temp);

               int false_index_patch = gen_code.emit("br label @");
               gen_code.bpatch($4->false_list, false_label);

               $$->next_list = gen_code.merge(gen_code.makelist({true_index_patch, FIRST}), gen_code.makelist({false_index_patch, FIRST}));
             }
        }
		| ID ASSIGN Exp SC {
			if(!semantic_stacks->is_exsists($1->name) || semantic_stacks->is_func($1->name))
			{
				output::errorUndef(yylineno,$1->name);
				exit(2);
			}

			if(convert_table[semantic_stacks->get_type($1->name)][$3->type] == false || (semantic_stacks->get_type($1->name) == TokenType::TOKEN_B && $3->type == TokenType::TOKEN_INT))
			{
				output::errorMismatch(yylineno);
				exit(2);
			}
			
			if($1->type == TokenType::TOKEN_B && $3->value > 255)
			{
				output::errorByteTooLarge(yylineno, std::to_string($3->value));
				exit(2);
			}
            $$=new Node();
			semantic_stacks->set_value($1->name,$3->value);
			string place = $3->place== ""? to_string($3->value) : $3->place;
			 if ($1->type != TokenType::TOKEN_BOOL)
            {
                string target = "%var"+to_string(gen_code.current_var++);
                string name = "%var"+ to_string(gen_code.current_var++);
                gen_code.emit("store i32 "+place+" , i32* "+name);
                gen_code.emit(name + " = getelementptr [50 x i32], [50 x i32]* %fp, i32 0 , i32 " + to_string(semantic_stacks->get_entry($1->name)->offset));
                $$->next_list = $3->next_list;
            }
            else
            {
               string true_temp = "%var"+ to_string(gen_code.current_var++);
               string false_temp = "%var"+ to_string(gen_code.current_var++);

               int unused_index = gen_code.emit("br label @");
               string true_label = gen_code.genLabel();
               gen_code.bpatch(gen_code.makelist({unused_index, FIRST}), true_label);

               gen_code.emit(declare_var_llvm(true_temp, to_string(semantic_stacks->get_args_last_func()->size()), semantic_stacks->get_entry($1->name)->offset));
               gen_code.emit("store i32 1 , i32* " + true_temp);

               int true_index_patch = gen_code.emit("br label @");
               gen_code.bpatch($4->true_list, true_label);

               string false_label = gen_code.genLabel();
               gen_code.emit(declare_var_llvm(false_temp, to_string(semantic_stacks->get_args_last_func()->size()), semantic_stacks->get_entry($1->name)->offset));
               gen_code.emit("store i32 0 , i32* " + true_temp);

               int false_index_patch = gen_code.emit("br label @");
               gen_code.bpatch($3->false_list, false_label);

               $$->next_list = gen_code.merge(gen_code.makelist({true_index_patch, FIRST}), gen_code.makelist({false_index_patch, FIRST}));
             }
		}
		| Call SC {$$=$1;}
		| RETURN SC {
			if(semantic_stacks->get_func_type() != TokenType::TOKEN_UNDIF)
			{
				output::errorMismatch(yylineno);
				exit(2);
			}
			gen_code.emit("ret void");
			$$=new Exp(TokenType::TOKEN_UNDIF,"",0);
			$$->return_statement=true;
		}

		| RETURN Exp M N M N M SC {
			if(convert_table[$2->type][semantic_stacks->get_func_type()] == TokenType::TOKEN_UNDIF || (semantic_stacks->get_func_type() == TokenType::TOKEN_B && $2->type == TokenType::TOKEN_INT))
			{
				output::errorMismatch(yylineno);
				exit(2);
			}
			semantic_stacks->update_last_func($2->value);
			$$=$2;//not sure if maybe new node
			$$->return_statement=true;
            if($2->type==TokenType::TOKEN_BOOL)
            {
                gen_code.bpatch($2->true_list,$3->quad);
                gen_code.bpatch($2->false_list,$5->quad);
                int buffer_index = gen_code.emit("br label @");
                string trueLabel = gen_code.genLabel();
                gen_code.bpatch(gen_code.makelist({buffer_index, FIRST}), trueLabel);
                int trueJump= gen_code.emit("ret i32 1");
                string falseLabel = gen_code.genLabel();
                int falseJump= gen_code.emit("ret i32 0");
                gen_code.bpatch($4->next_list,trueLabel);
                gen_code.bpatch($6->next_list,falseLabel);
            }
            else
            {
                gen_code.bpatch(gen_code.merge($4->next_list,$6->next_list),$7->quad);
                gen_code.emit("ret i32 " + to_string($2->value));
                $$->next_list = $2->next_list;
            }
		}
		| IfExp M Statement
		{
		    $$=new Node();
            $$->quad=$2->quad;
            semantic_stacks->exit_scope();
            gen_code.bpatch($1->true_list, $$->quad);

           $$->next_list = gen_code.merge($1->false_list, $3->next_list);
           $$->continue_list = $3->continue_list;
           $$->break_list = $3->break_list;
           gen_code.bpatch($1->start_list, $1->start_label);
               	    } %prec NOELSE
		| IfExp M Statement ELSE N M { semantic_stacks->new_scope(); } Statement { semantic_stacks->exit_scope(); } %prec ELSE
		        {
		            $$=new Node();
		            gen_code.bpatch($1->true_list,$2->quad);
                    gen_code.bpatch($1->false_list,$6->quad);


                    $$->next_list = gen_code.merge($3->next_list, $7->next_list);
                    $$->next_list = gen_code.merge($$->next_list, $5->next_list);
                    $$->break_list = gen_code.merge($3->break_list, $7->break_list);
                    $$->continue_list = gen_code.merge($3->continue_list, $7->continue_list);
                    gen_code.bpatch($1->start_list, $1->start_label);
		        }
		| WHILE M LPAREN Exp RPAREN {

			if($4->type != TokenType::TOKEN_BOOL)
			{
				output::errorMismatch(yylineno);
				exit(2);
			}

			semantic_stacks->whilecounter++;
			semantic_stacks->new_scope();
			} M Statement {
                $$=new Node();
                $$->true_list = $4->true_list;
                $$->false_list = $4->false_list;
                $$->quad = $2->quad;
			      gen_code.bpatch($4->true_list,$7->quad);


			      gen_code.bpatch($8->next_list, $2->quad);
                  gen_code.bpatch($8->continue_list, $2->quad);

                  $$->next_list = gen_code.merge($4->false_list, $8->break_list);

                  int label_index = gen_code.emit(br_loop_llvm($8->quad));
                  gen_code.bpatch(gen_code.makelist({label_index, FIRST}), $8->quad);
				semantic_stacks->whilecounter--;
				semantic_stacks->exit_scope();
				//not sure if we need to update start label. think not
			}
		| BREAK SC {
			if(semantic_stacks->whilecounter == 0)
			{
				output::errorUnexpectedBreak(yylineno);
				exit(2);
			}
			$$=new Node();
			int label_index = gen_code.emit("br label @");
            $$->break_list = gen_code.makelist({label_index, FIRST});
		}
		| CONTINUE SC {
			if(semantic_stacks->whilecounter == 0)
			{
				output::errorUnexpectedContinue(yylineno);
				exit(2);
			}
			int label_index = gen_code.emit("br label @");
            $$=new Node();
            $$->continue_list = gen_code.makelist({label_index, FIRST});
		}
		;
IfExp:  IF LPAREN Exp RPAREN {
		if($3->type != TokenType::TOKEN_BOOL)
		{
		    printf("here");
		    fflush(stdout);
			output::errorMismatch(yylineno);
			exit(2);
		}
		semantic_stacks->new_scope();
        gen_code.bpatch($3->start_list, $3->start_label);
        $$=$3;
	};
Call:	ID LPAREN ExpList M RPAREN {
			if(!semantic_stacks->is_exsists($1->name) || !semantic_stacks->is_func($1->name))
			{
				output::errorUndefFunc(yylineno,$1->name);
				exit(2);
			}

			vector<pair<TokenType,string>>* func_args = semantic_stacks->get_args($1->name);
			if(func_args->size() != $3->get_vars()->size())
			{
				output::errorPrototypeMismatch(yylineno,$1->name, *(semantic_stacks->get_string_args($1->name)));
				exit(2);
			}
			
			for(int i = 0; i < func_args->size(); i++)
			{
				if(convert_table[func_args->at(i).first][$3->get_vars()->at(i).type] == TokenType::TOKEN_UNDIF || (func_args->at(i).first == TokenType::TOKEN_B && $3->get_vars()->at(i).type == TokenType::TOKEN_INT))
				{
					output::errorPrototypeMismatch(yylineno, $1->name, *(semantic_stacks->get_string_args($1->name)));
					exit(2);
				}
			}

			$$ = new Call(semantic_stacks->get_type($1->name), $1->name,semantic_stacks->get_value($1->name));
			gen_code.bpatch($3->true_list,$4->quad);
              gen_code.bpatch($3->false_list,$4->quad);
            if ($1->name == "print")
            {
                string str = $3->get_vars()->front().name;
                string str_len = to_string(str.length() - 1);
                gen_code.emit("call void @print (i8* getelementptr ([" + str_len + " x i8], [" + str_len + " x i8]* " + str + ", i32 0, i32 0))");
            }
            else
            {
                TokenType ret_type = semantic_stacks->get_func_type($1->name);
                string args_llvm = "";
                for(int i=0; i<$3->get_vars()->size();i++)
                {
                    args_llvm = args_llvm + "i32 " + to_string($3->get_vars()->at(i).value) + ",";
                }
                /* Cut the last "," */
                args_llvm = args_llvm.substr(0, args_llvm.length() - 1);
                if(ret_type==TokenType::TOKEN_UNDIF)
                {
                    int index=gen_code.emit("call void @" + $1->name + "(" + args_llvm + ")");
                    gen_code.bpatch($3->false_list,to_string(index));
                    gen_code.bpatch($3->true_list,to_string(index));
                    gen_code.bpatch($3->next_list,to_string(index));
                }
                else
                {
                    gen_code.emit("call i32 @" + $1->name + "(" + args_llvm + ")");
                    string target = "%var"+to_string(gen_code.current_var++);
                    string return_type_llvm = ret_type==TokenType::TOKEN_UNDIF ? "void" : "i32";
                    gen_code.emit(target + " = call " + return_type_llvm + " @" + $1->name + "(" + args_llvm + ")");
                    $$->place=target;
                    if (ret_type == TokenType::TOKEN_BOOL)
                    {
                        string target_boolean = "%var"+to_string(gen_code.current_var++);
                        gen_code.emit(target_boolean + " = icmp ne i32 0, " + $$->place);
                        int label_index = gen_code.emit("br i1 " + target_boolean + " , label @ , label @");
                        $$->true_list = gen_code.makelist({label_index, FIRST});
                        $$->false_list = gen_code.makelist({label_index, SECOND});
                    }
                }
            }
        $$->start_label = $3->start_label;
         gen_code.bpatch($$->start_list, $$->start_label);

		}
		| ID LPAREN RPAREN {
			if(!semantic_stacks->is_exsists($1->name) || !semantic_stacks->is_func($1->name))
			{
				output::errorUndefFunc(yylineno,$1->name);
				exit(2);
			}
			vector<pair<TokenType,string>>* args=semantic_stacks->get_args($1->name);
			if(args->size()!=0)
			{
				output::errorPrototypeMismatch(yylineno,$1->name, *(semantic_stacks->get_string_args($1->name)));
				exit(2);
			}
			$$ = new Call(semantic_stacks->get_type($1->name), $1->name,semantic_stacks->get_value($1->name));

            TokenType ret_type = semantic_stacks->get_func_type($1->name);
            string args_llvm = "";
                if(ret_type==TokenType::TOKEN_UNDIF)
                {
                    int index=gen_code.emit("call void @" + $1->name + "()");
                }
                  else
                {
                    gen_code.emit("call i32 @" + $1->name + "()");
                    string target = "%var"+to_string(gen_code.current_var++);
                    string return_type_llvm = ret_type==TokenType::TOKEN_UNDIF ? "void" : "i32";
                    gen_code.emit(target + " = call " + return_type_llvm + " @" + $1->name + "()");
                    $$->place=target;
                    if (ret_type == TokenType::TOKEN_BOOL)
                {
                    string target_boolean = "%var"+to_string(gen_code.current_var++);
                    gen_code.emit(target_boolean + " = icmp ne i32 0, " + $$->place);
                    int label_index = gen_code.emit("br i1 " + target_boolean + " , label @ , label @");
                    $$->true_list = gen_code.makelist({label_index, FIRST});
                    $$->false_list = gen_code.makelist({label_index, SECOND});
                 }
            }
            int x = gen_code.emit("br label @");
            std::string call_label = gen_code.genLabel();
            gen_code.bpatch(gen_code.makelist({x, FIRST}), call_label);
            $$->start_label = call_label;
            gen_code.bpatch($$->start_list, $$->start_label);
		}
		;

ExpList: Exp {
			ExpList *explist = new ExpList(); 
			explist->vars->push_back(Exp(*$1));
			$$ = explist;
            if ($1->type == TokenType::TOKEN_BOOL)
            {
                string target = "%var"+to_string(gen_code.current_var++);
                int unused_index = gen_code.emit("br label @");

                string true_label = gen_code.genLabel();
                gen_code.bpatch(gen_code.makelist({unused_index, FIRST}), true_label);
                int true_index = gen_code.emit("br label @");
                gen_code.bpatch($1->true_list, true_label);

                string false_label =gen_code.genLabel();
                gen_code.bpatch(gen_code.makelist({unused_index, FIRST}), false_label);
                int false_index = gen_code.emit("br label @");
                gen_code.bpatch($1->false_list, false_label);

                string next_label = gen_code.genLabel();
                gen_code.bpatch(gen_code.makelist({true_index, FIRST}), next_label);
                gen_code.bpatch(gen_code.makelist({false_index, FIRST}), next_label);
                gen_code.emit(target + " = phi i32 [ 1, %" + true_label + " ] , [ 0, %" + false_label + "]");
                $$->place = target;
            }
            $$->true_list=$1->true_list;
            $$->false_list=$1->false_list;
		}
		| Exp COMMA ExpList {
			Exp* exp = new Exp($1->type, $1->name, $1->value);
			$3->get_vars()->insert($3->get_vars()->begin(), Exp(*exp));
			$$ = $3;
			if ($1->type == TokenType::TOKEN_BOOL)
            {
                string target = "%var"+to_string(gen_code.current_var++);
                int unused_index = gen_code.emit("br label @");

                string true_label = gen_code.genLabel();
                gen_code.bpatch(gen_code.makelist({unused_index, FIRST}), true_label);
                int true_index = gen_code.emit("br label @");
                gen_code.bpatch($1->true_list, true_label);

                string false_label =gen_code.genLabel();
                gen_code.bpatch(gen_code.makelist({unused_index, FIRST}), false_label);
                int false_index = gen_code.emit("br label @");
                gen_code.bpatch($1->false_list, false_label);

                string next_label = gen_code.genLabel();
                gen_code.bpatch(gen_code.makelist({true_index, FIRST}), next_label);
                gen_code.bpatch(gen_code.makelist({false_index, FIRST}), next_label);
                gen_code.emit(target + " = phi i32 [ 1, %" + true_label + " ] , [ 0, %" + false_label + "]");
                $$->place = target;
            }
            $$->true_list = gen_code.merge($1->true_list, $3->true_list);
            $$->false_list = gen_code.merge($1->false_list, $3->false_list);
		}
		;

Type: INT {
		$$ = new Node(TokenType::TOKEN_INT, "", 0);
	}
	| BYTE {
		$$ = new Node(TokenType::TOKEN_B, "", 0);
	}
	| BOOL {
		$$ = new Node(TokenType::TOKEN_BOOL, "", 0);
	}
	;

Exp: LPAREN Exp RPAREN {
		$$ = new Exp($2->type, $2->name, $2->value);
		$$->true_list = $2->true_list;
		$$->false_list = $2->false_list;
		$$->break_list = $2->break_list;
		$$->continue_list = $2->continue_list;
		$$->next_list = $2->next_list;
	}
	| Exp IF N LPAREN Exp RPAREN ELSE Exp {
		if($5->type != TokenType::TOKEN_BOOL)
		{
			output::errorMismatch(yylineno);
			exit(2);
		}
		if(convert_table[$1->type][$8->type] == TokenType::TOKEN_UNDIF)
		{
			output::errorMismatch(yylineno);
			exit(2);
		}
		
		if($5->value == 1)
			$$ = new Exp($1->type, $1->name, $1->value);
		else
			$$ = new Exp($8->type, $8->name, $8->value);


            NMarkerNode* jmp_to_end_label = new NMarkerNode();
            std::string to_start_label = gen_code.genLabel();

            NMarkerNode* middle_jmp = new NMarkerNode();
            std::string middle_label = gen_code.genLabel();

            NMarkerNode* jmp_to_bool_exp = new NMarkerNode();
            std::string end_label = gen_code.genLabelPhi();

            gen_code.bpatch($1->start_list, to_start_label);
            gen_code.bpatch($8->start_list, $8->start_label);
            gen_code.bpatch($5->true_list, $1->start_label);
            gen_code.bpatch($5->false_list, $8->start_label);
            gen_code.bpatch($5->start_list, $5->start_label);


            std::vector<pair<int, BranchLabelIndex>> all_jumps_to_end = gen_code.merge($3->next_list, jmp_to_end_label->next_list);
            gen_code.bpatch(all_jumps_to_end, end_label);
            gen_code.bpatch(jmp_to_bool_exp->next_list, $5->start_label);
            $$->place = "%var"+to_string(gen_code.current_var++);
            gen_code.bpatch($1->start_list, to_start_label);
            std::string phi_true_label = $1->trinary ? $1->start_label_trinary: $1->start_label;
            std::string phi_false_label = $8->trinary ? $8->start_label_trinary: $8->start_label;
            gen_code.emit($$->place +" = phi i32 [" + $1->place +", %" + phi_true_label + "] , [" + $8->place +  " , %" + phi_false_label+"]");
            $$->start_label_trinary = end_label;
            $$->start_label = middle_label;
            $$->start_list = middle_jmp->next_list;
            $$->trinary = true;
	}


	| Exp PLUS Exp {
		TokenType new_type;
		int new_val;
		if($1->type==TokenType::TOKEN_STRING||$1->type==TokenType::TOKEN_BOOL||$3->type==TokenType::TOKEN_STRING||$3->type==TokenType::TOKEN_BOOL)
		{
		printf("%u",$3->type);
		fflush(stdout);
			output::errorMismatch(yylineno);
			exit(2);
		}
		
		if($1->type == TokenType::TOKEN_INT || $3->type == TokenType::TOKEN_INT)
			new_type = TokenType::TOKEN_INT;
		else
			new_type = TokenType::TOKEN_B;
		
		if($2->name == "+")
			new_val = $1->value + $3->value;
		else if($2->name == "-")
			new_val = $1->value - $3->value;
		$$ = new Exp(new_type, std::to_string(new_val), new_val);


		string target = "%var"+to_string(gen_code.current_var++);

        string right_place = $3->place;
        string left_place = $1->place;

        /* The values to use */
        string right = right_place == "" ? to_string($3->value) : right_place;
        string left = left_place == "" ? to_string($1->value) : left_place;

        bool can_overflow = false;
        /* Byte overflow */
        if ($1->type == TokenType::TOKEN_B && $3->type == TokenType::TOKEN_B)
		{

			string left_var = "%var"+to_string(gen_code.current_var++);
			gen_code.emit(left_var + " = trunc i32 " + to_string($1->value) + " to i8");

			string right_var = "%var"+to_string(gen_code.current_var++);
			gen_code.emit(right_var + " = trunc i32 " + to_string($1->value) + " to i8");

			/* Bubble the updates */
			left = left_var;
			right = right_var;

			can_overflow = true;
		}

		string op_type_llvm = can_overflow ? "i8" : "i32";
	    if ($2->name == "+")
		{
		gen_code.emit(target + " = add " + op_type_llvm + " " + left + ", " +right);
		}
		else if ($2->name == "-")
		{
			gen_code.emit(target + " = sub " + op_type_llvm + " " + left + ", " +right);
		}

		if (can_overflow)
		{
			string next_var = "%var"+to_string(gen_code.current_var++);
			gen_code.emit(next_var + " = zext i8 " + target + " to i32");
			target = next_var;
		}
		$$->place = target;
		gen_code.bpatch($3->start_list, $3->start_label);
        $$->start_label = $1->start_label;
        $$->start_list = $1->start_list;
	}
	| Exp MULTI Exp  {
		TokenType new_type;
		int new_val;
		if($1->type == TokenType::TOKEN_STRING || $1->type == TokenType::TOKEN_BOOL || $3->type == TokenType::TOKEN_STRING || $3->type == TokenType::TOKEN_BOOL)
		{
			output::errorMismatch(yylineno);
			exit(2);
		}
		
		if($1->type == TokenType::TOKEN_INT || $3->type == TokenType::TOKEN_INT)
			new_type = TokenType::TOKEN_INT;
		else
			new_type = TokenType::TOKEN_B;
		
		if($2->name == "*")
			new_val = $1->value * $3->value;
		else if($2->name == "/")
		{
			new_val = $1->value / $3->value;
		}
		$$ = new Exp(new_type, std::to_string(new_val), new_val);


          string target = "%var"+to_string(gen_code.current_var++);

          string right_place = $3->place;
          string left_place = $1->place;

          string right = right_place == "" ? to_string($3->value) : right_place;
          string left = left_place == "" ? to_string($1->value): left_place;

          bool can_overflow = false;
          if ($2->name != "/" && $1->type == TokenType::TOKEN_B && $3->type == TokenType::TOKEN_B)
          {

            string left_var = "%var"+to_string(gen_code.current_var++);
            gen_code.emit(left_var + " = trunc i32 " + to_string($1->value) + " to i8");

            string right_var = "%var"+to_string(gen_code.current_var++);
            gen_code.emit(right_var + " = trunc i32 " + to_string($1->value) + " to i8");

            /* Bubble the updates */
            left = left_var;
            right = right_var;

            can_overflow = true;
          }

          string op_type_llvm = can_overflow ? "i8" : "i32";

          if ($2->name == "/")
          {
            string zero_var_llvm = "%var"+to_string(gen_code.current_var++);
            string zero_source = right_place == "" ? to_string($3->value) : right_place;

            gen_code.emit(zero_var_llvm + " = icmp eq i32 " + zero_source + ", 0");
            int zero_bp = gen_code.emit("br i1 " + zero_var_llvm + " , label @ , label @");

            string error_label = gen_code.genLabel();
            gen_code.emit("call i32 (i8*, ...) @printf(i8* getelementptr([24 x i8], [24 x i8]* @.zero_div, i32 0, i32 0))");
            gen_code.emit("call void @exit(i32 0)");

            int unused_bp = gen_code.emit("br label @");

            string success_label = gen_code.genLabel();
            gen_code.emit(target + " = sdiv " + op_type_llvm+ " "+ left+ ", "+ right);
            gen_code.bpatch(gen_code.makelist({zero_bp, SECOND}), success_label);
            gen_code.bpatch(gen_code.makelist({zero_bp, FIRST}), error_label);
            gen_code.bpatch(gen_code.makelist({unused_bp, FIRST}), success_label);
          }
          else if ($2->name == "*")
          {
            gen_code.emit(target + " = mul " + op_type_llvm+ " "+ left+ ", " +right);
          }

          /* Handle overflow / sign */
          if (can_overflow)
          {
            string next_var = "%var"+to_string(gen_code.current_var++);
            gen_code.emit(next_var + " = zext i8 " + target + " to i32");
            target = next_var;
          }
          $$->place = target;
          gen_code.bpatch($3->start_list, $3->start_label);
          $$->start_label = $1->start_label;
          $$->start_list = $1->start_list;
        }
	| ID  {

		if(semantic_stacks->is_func($1->name))
		{
			output::errorUndef(yylineno,$1->name);
			exit(2);
		}

		TokenType type = semantic_stacks->get_type($1->name);
		
		if(TOKEN_UNDIF==type)
		{
			output::errorUndef(yylineno, $1->name);
			exit(2);
		}

		$$ = new Exp(type, $1->name, semantic_stacks->get_value($1->name));
        string source = "%var"+to_string(gen_code.current_var++);
        string target = "%var"+to_string(gen_code.current_var++);

        int size_of_args = semantic_stacks->get_args_last_func()->size();

        table_entry * entry=semantic_stacks->get_entry($1->name);

          gen_code.emit(declare_var_llvm(source, to_string(size_of_args), entry->offset));
          gen_code.emit(target + " = load i32, i32* " + source);
          $$->place = target;
          if(entry->offset>=0)
          {
              int loc = gen_code.emit("br label @");
              $1->start_label = gen_code.genLabel();
              $1->start_list = gen_code.makelist({loc, FIRST});
          }
          if (entry->type == TokenType::TOKEN_BOOL)
          {
              if (entry->offset<0)
              {
                  int loc = gen_code.emit("br label @");
                  $1->start_label = gen_code.genLabel();
                  $1->start_list = gen_code.makelist({loc, FIRST});
              }
            string target_boolean = "%var"+to_string(gen_code.current_var++);
            gen_code.emit(target_boolean + " = icmp ne i32 0, " + source);
            int branch_index = gen_code.emit("br i1 " + target_boolean + " , label @ , label @");
            auto unconditional_list = gen_code.makelist({branch_index, FIRST});
            auto conditional_list = gen_code.makelist({branch_index, SECOND});

            $$->true_list = unconditional_list;
            $$->false_list = conditional_list;
          }


	}
	| Call {}
	| NUM {
		$$->type = $1->type;
        $$->value = $1->value;
	}
	| NUM B {
		$$->type = TokenType::TOKEN_B;
      	$$->value = $1->value;
      	if ($1->value > 255)
		{
        	output::errorByteTooLarge(yylineno, std::to_string($1->value)); 
			exit(2);
		}
	}
	| STRING {
		$$ = new Exp($1->type, $1->name, $1->value);
	}
	| TRUE  {
		$$ = new Exp(TokenType::TOKEN_BOOL, "TRUE",1);
		int label_index = gen_code.emit("br label @");
        $$->true_list = gen_code.makelist({label_index, FIRST});
	}
	| FALSE  {
		$$ = new Exp(TokenType::TOKEN_BOOL, "FALSE",0);
		int label_index = gen_code.emit("br label @");
        $$->false_list = gen_code.makelist({label_index, FIRST});
	}
	| NOT Exp  {
		if($2->value == 0) 
			$$ = new Exp($2->type, "TRUE", 1);
		else 
			$$ = new Exp($2->type, "FALSE", 0);
		string flippedBool = "%var"+to_string(gen_code.current_var++);
        string newPlace = "%var"+to_string(gen_code.current_var++);
        gen_code.emit(flippedBool + " = icmp ne i32 1, " + $2->place);
        gen_code.emit(newPlace + "= zext " + flippedBool +" i1 to i32");
        $$->place=newPlace;
        $$->true_list=$2->false_list;
        $$->false_list=$2->true_list;
	}
	| Exp AND M Exp  {
		if($1->type != TokenType::TOKEN_BOOL || $4->type != TokenType::TOKEN_BOOL)
		{
			output::errorMismatch(yylineno);
			exit(2);
		}

		int new_val = $1->value & $4->value;
		if(new_val == 0)
			$$ = new Exp($1->type, "FALSE", new_val);
		else 
			$$ = new Exp($1->type, "TRUE", new_val);
		$$->quad=$3->quad;
		gen_code.bpatch($1->true_list, $$->quad);
        $$->true_list = $4->true_list;
        $$->false_list = gen_code.merge($1->false_list, $4->false_list);
        gen_code.bpatch($4->start_list, $4->start_label);
        $$->start_label = $1->start_label;
        $$->start_list = $1->start_list;
		}
		| Exp OR M Exp  {
			if($1->type != TokenType::TOKEN_BOOL || $4->type != TokenType::TOKEN_BOOL)
			{
				output::errorMismatch(yylineno);
				exit(2);
			}
			
			int new_val = $1->value | $4->value;
			if(new_val == 0) 
				$$ = new Exp($1->type, "FALSE", new_val);
			else 
				$$ = new Exp($1->type, "TRUE", new_val);

			gen_code.bpatch($1->false_list, $$->quad);
            $$->false_list = $4->false_list;
            $$->true_list = gen_code.merge($1->true_list, $4->true_list);
            gen_code.bpatch($4->start_list, $4->start_label);
            $$->start_label = $1->start_label;
            $$->start_list = $1->start_list;
		}		
		| Exp RELOP Exp  {
			//Mismatch check
			if($1->type == TokenType::TOKEN_UNDIF || $1->type == TokenType::TOKEN_BOOL || $1->type == TokenType::TOKEN_STRING ||
				$3->type == TokenType::TOKEN_UNDIF || $3->type == TokenType::TOKEN_STRING || $3->type == TokenType::TOKEN_BOOL)
			{
			    printf("here1");
			    fflush(stdout);
				output::errorMismatch(yylineno);
				exit(2);
			}

			//Value update
			int new_val;
			if($2->name == "==")
				new_val = $1->value == $3->value;
			if($2->name == "!=")
				new_val = $1->value != $3->value;
			if($2->name == "<")
				new_val = $1->value < $3->value;
			if($2->name == ">")
				new_val = $1->value > $3->value;
			if($2->name == "<=")
				new_val = $1->value <= $3->value;
			if($2->name == ">=")
				new_val = $1->value >= $3->value;

			if(new_val == 1) 
				$$ = new Exp(TokenType::TOKEN_BOOL, "TRUE", new_val);
			else 
				$$ = new Exp(TokenType::TOKEN_BOOL, "FALSE", new_val);

			string right_value = to_string($3->value);
            string left_value = to_string($1->value);

            /* The values to use */
    		string right = $3->place == "" ? right_value : $3->place;
            string left = $1->place == "" ? left_value : $1->place;
            string op_llvm = "eq"; /* == */

            if ($2->name == ">")
            {
            	op_llvm = "sgt";
            }
            else if ($2->name == ">=")
            {
                op_llvm = "sge";
            }
            else if ($2->name == "<")
            {
                op_llvm = "slt";
            }
            else if ($2->name == "<=")
            {
                op_llvm = "sle";
            }
            else if ($2->name == "!=")
            {
                op_llvm = "ne";
            }
            string target = "%var"+to_string(gen_code.current_var++);
            string finalRes = "%var"+to_string(gen_code.current_var++);
            gen_code.emit(target + " = icmp " + op_llvm + " i32 " + left + ", " + right);

            int label_index = gen_code.emit("br i1 " + target + " , label @ , label @");
            gen_code.emit(finalRes + " = zext i8 " + target + " to i32");

            $$->true_list = gen_code.makelist({label_index, FIRST});
            $$->false_list = gen_code.makelist({label_index, SECOND});
            $$->place = finalRes;
            gen_code.bpatch($3->start_list, $3->start_label);
            $$->start_label = $1->start_label;
            $$->start_list = $1->start_list;
	}
	| LPAREN Type RPAREN Exp %prec CAST   {
		if(convert_table[$2->type][$4->type] == TokenType::TOKEN_UNDIF)
		{
			output::errorMismatch(yylineno);
			exit(2);
		}
		if($2->type == TokenType::TOKEN_BOOL) 
			{
			    $$ = $4;
			}
		if($2->type == TokenType::TOKEN_INT)
			{
			    $$ = new Exp($2->type,$4->name,$4->value);
			    if($4->type==TokenType::TOKEN_B)
			    {
			         string next_var = "%var"+to_string(gen_code.current_var++);
					 auto target = $4->place == "" ? to_string($4->value) : $4->place;
                     gen_code.emit(next_var + " = zext i8 " + target + " to i32");
                     $$->place = next_var;
			    }
			}
		if($2->type == TokenType::TOKEN_B)
		{
			if($4->type == TokenType::TOKEN_INT && $4->value > 255) 
			{
				output::errorByteTooLarge(yylineno, std::to_string($4->value));
				exit(2);
			}
			$$ = new Exp($2->type,$4->name,$4->value);
			string next_var = "%var"+to_string(gen_code.current_var++);
			auto target = $4->place == "" ? to_string($4->value) : $4->place;
			gen_code.emit(next_var + " = trunc i32 " + target + " to i8");
			$$->place = next_var;
		}
	}
	;


%%

int yyerror(const char* const s)
{
  extern int yylineno;
  output::errorSyn(yylineno);
  exit(2);
}

int main(){
//yydebug=1;

     int ret= yyparse();
	gen_code.emitGlobal(printf_llvm);
    gen_code.emitGlobal(zero_div_llvm);
    gen_code.emitGlobal(printi_llvm);

    gen_code.emitGlobal(print_llvm);
    gen_code.emitGlobal(exit_llvm);

    gen_code.printGlobalBuffer();
    gen_code.printCodeBuffer();
    return ret;
}

