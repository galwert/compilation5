%{
#include <iostream>
#include "llvm.cpp"
#include "parser.hpp"
#include "hw3_output.hpp"
#include "bp.hpp"
#include <climits>
extern int yylineno;
using namespace std;
int yyerror(const char * const s);
int yylex(void);
Stacks* semantic_stacks;
#define YYDEBUG 1
#define gen_code (CodeBuffer::instance())

TokenType convert_table[5][5]={
        {/*UNDIF TO*/
                /*TOKEN_UNDIF*/TOKEN_UNDIF,
                /*TOKEN_INT*/TOKEN_UNDIF,
                /*TOKEN_B*/TOKEN_UNDIF,
                /*TOKEN_BOOL*/TOKEN_UNDIF,
                /*TOKEN_STRING*/TOKEN_UNDIF
        },
        {/*INT TO*/
                /*TOKEN_UNDIF*/TOKEN_UNDIF,
                /*TOKEN_INT*/TOKEN_INT,
                /*TOKEN_B*/TOKEN_INT,
                /*TOKEN_BOOL*/TOKEN_UNDIF,/*not sure*/
                /*TOKEN_STRING*/TOKEN_UNDIF
        },
        {/*B TO*/
                /*TOKEN_UNDIF*/TOKEN_UNDIF,
                /*TOKEN_INT*/TOKEN_INT,
                /*TOKEN_B*/TOKEN_B,
                /*TOKEN_BOOL*/TOKEN_UNDIF,
                /*TOKEN_STRING*/TOKEN_UNDIF
        },
        {/*BOOL TO*/
                /*TOKEN_UNDIF*/TOKEN_UNDIF,
                /*TOKEN_INT*/TOKEN_UNDIF,
                /*TOKEN_B*/TOKEN_UNDIF,
                /*TOKEN_BOOL*/TOKEN_BOOL,
                /*TOKEN_STRING*/TOKEN_UNDIF
        },
        {/*STRING TO*/
                /*TOKEN_UNDIF*/TOKEN_UNDIF,
                /*TOKEN_INT*/TOKEN_UNDIF,
                /*TOKEN_B*/TOKEN_UNDIF,
                /*TOKEN_BOOL*/TOKEN_UNDIF,
                /*TOKEN_STRING*/TOKEN_STRING
        }
};


%}

%token VOID INT BYTE B BOOL TRUE FALSE RETURN WHILE BREAK CONTINUE SC COMMA LBRACE RBRACE ID NUM STRING
%right ASSIGN
%left OR
%left AND

%left PLUS
%left MULTI
%right NOT
%right RPAREN
%right LPAREN

%nonassoc NOELSE
%nonassoc ELSE

%nonassoc IF
%nonassoc RELOP
%nonassoc CAST
%token YYEOF
%%


M:
    %empty                            {
          int buffer_index = gen_code->emit("br label @");
          string label = gen_code->genLabel();
          gen_code->bpatch(gen_code->makelist({buffer_index, FIRST}), label);
          $$->quad = label;
    };

N:
    %empty                            {
          int buffer_index = gen_code->emit("br label @");
          string label = gen_code->genLabel();
          gen_code->bpatch(gen_code->makelist({buffer_index, FIRST}), label);
          $$->quad = label;
       $$->next_list = gen_code->makelist({gen_code->emit("br label @"), FIRST});
    };

Program:   
		{ semantic_stacks=new Stacks(); }
		Funcs YYEOF {
			if(!semantic_stacks->is_exsists("main") || !semantic_stacks->is_func("main") || semantic_stacks->get_type("main") != TokenType::TOKEN_UNDIF || semantic_stacks->get_args("main")->size()!=0)
			{
				output::errorMainMissing();
				exit(2);
			}
		} 
		{ semantic_stacks->exit_scope(); }
		;

Funcs:		/*epsilon*/
	| FuncDecl Funcs {}
		;

FuncDecl: 
		RetType ID LPAREN Formals RPAREN  {
			if(semantic_stacks->is_exsists($2->name))
			{
				output::errorDef(yylineno,$2->name);
				exit(2);
			}

			for(int i=0; i<$4->get_args()->size();i++)
			{
				if($4->get_args()->at(i).second == $2->name)
				{
					output::errorDef(yylineno,$2->name);
					exit(2);
				}
			}

			semantic_stacks->new_func($2->name,$1->type,$4->get_args());
			string type_in_str = $1->type==TokenType::TOKEN_UNDIF ? "void" : "i32";
            string args = "";
            for (auto i = 0; i < $4->get_args()->size(); i++)
            {
                args = args + "i32 ,";
            }
            args = args.substr(0, args.length() - 1);
			gen_code->emit("define " + type_in_str + " @" + $2->name + "(" + args + ") {");
			gen_code->emit("entry:
			        %fp = alloca [50 x i32]");
		}
            LBRACE Statements RBRACE {
            semantic_stacks->exit_scope();gen_code->emit("}");
             }
		;

RetType:		
		Type { $$ = $1; }
		| VOID { $$ = new Node(TokenType::TOKEN_UNDIF,"",0); }
		;

Formals:		
		{ $$ = new FormalList(); }
		| FormalsList { $$ = $1; }
		;
FormalsList:	
			FormalDecl {if(semantic_stacks->is_exsists($1->name)){output::errorDef(yylineno,$1->name); exit(2);}$$ = new FormalList(); $$->get_args()->insert($$->get_args()->begin(),pair<TokenType,string>($1->type,$1->name));}
			| FormalDecl COMMA FormalsList 
			{
				vector<pair<TokenType,string>>* args = $3->get_args();
				for(int i=0;i<args->size();i++)
					if(args->at(i).second == $1->name)
					{
						output::errorDef(yylineno,$1->name);
						exit(2);
					}
				if(semantic_stacks->is_exsists($1->name))
				{
					output::errorDef(yylineno,$1->name);
					exit(2);
				}
				$3->get_args()->insert($3->get_args()->begin(),pair<TokenType,string>($1->type,$1->name));
				$$ = $3;
			}
			;

FormalDecl: 	
			Type ID { $$ = new Node($1->type,$2->name,0); }
		;
Statements:	
			Statement {
			$$->next_list = $1->next_list;
                  $$->break_list = $1->break_list;
                  $$->continue_list = $1->continue_list;
            }
			| Statements M Statement  {
			        if ($3->return_statement == false)
                    {
                        gen_code->bpatch(atom_statements->next_list, atom_marker->quad);
                    }
                    $$->next_list = $3->next_list;
                    $$->break_list = gen_code->merge($1->break_list,$3->break_list);
                    $$->continue_list = gen_code->merge($1->continue_list,$3->continue_list);
            }
		;

Statement:	
		LBRACE {

		    semantic_stacks->new_scope();
		}
		Statements M RBRACE
		{
             $$ = new Node();
             $$->next_list = $2->next_list;
             $$->break_list = $2->break_list;
             $$->continue_list = $2->continue_list;
             gen_code->bpatch($3->next_list,$3->quad);
            semantic_stacks->exit_scope();
		}

		| Type ID SC {
			if(semantic_stacks->is_exsists($2->name))
			{
				output::errorDef(yylineno,$2->name);
				exit(2);
			}
			$$ = new Node($1->type, $2->name, 0);
			semantic_stacks->new_entry($2->name,$1->type,0);
			string name = "%var"+ gen_code->current_var++;
            gen_code->emit("store i32 0 , i32* "+name);
            gen_code->emit(name + " = getelementptr [50 x i32], [50 x i32]* %fp, i32 0 , i32 " + to_string(semantic_table->get_entry($2->name)->offset));
		}
		| Type ID ASSIGN Exp SC {
			if(semantic_stacks->is_exsists($2->name))
			{
				output::errorDef(yylineno,$2->name);
				exit(2);
			}

			if(convert_table[$1->type][$4->type] == false || ($1->type == TokenType::TOKEN_B && $4->type == TokenType::TOKEN_INT))
			{
				output::errorMismatch(yylineno);
				exit(2);
			}
			
			if($2->type == TokenType::TOKEN_B && $4->value > 255)
			{
				output::errorByteTooLarge(yylineno, std::to_string($3->value));
				exit(2);
			}
			
			$$ = new Node($1->type,$2->name,$4->value);
			semantic_stacks->new_entry($2->name,$1->type,$4->value);

			string place = $4->place== ""? to_string($4->value) : $4->place;


            if ($1->type != TokenType::TOKEN_BOOL)
            {
                string target = "%var"+to_string(gen_code->current_var++);
                string name = "%var"+ gen_code->current_var++;
                gen_code->emit(name + " = getelementptr [50 x i32], [50 x i32]* %fp, i32 0 , i32 " + to_string(semantic_table->get_entry($2->name)->offset));
                gen_code->emit("store i32 "+$4->value+" , i32* "+name);
                 $$->next_list = $4->next_list;
            }
            else
            {
               string true_temp = "%var"+ to_string(gen_code->current_var++);
               string false_temp = "%var"+ to_string(gen_code->current_var++);

               int unused_index = gen_code->emit("br label @");
               string true_label = gen_code->genLabel();
               gen_code->bpatch(gen_code->makelist({unused_index, FIRST}), true_label);

               gen_code->emit(declare_var_llvm(true_temp, "0", to_string(semantic_table->get_entry($2->name)->offset)));
               gen_code->emit("store i32 1 " , i32* " + true_temp);

               int true_index_patch = gen_code->emit("br label @");
               gen_code->bpatch($4->true_list, true_label);

               int false_label = gen_code->genLabel();
               gen_code->emit(declare_var_llvm(false_temp, "0", to_string(semantic_table->get_entry($2->name)->offset)));
               gen_code->emit("store i32 0 " , i32* " + true_temp");

               int false_index_patch = gen_code->emit("br label @");
               gen_code->bpatch($4->false_list, false_label);

               $$->next_list = gen_code->merge(gen_code->makelist({true_index_patch, FIRST}), gen_code->makelist({false_index_patch, FIRST}));
             }
           }
		}
		| ID ASSIGN Exp SC {
			if(!semantic_stacks->is_exsists($1->name) || semantic_stacks->is_func($1->name))
			{
				output::errorUndef(yylineno,$1->name);
				exit(2);
			}

			if(convert_table[semantic_stacks->get_type($1->name)][$3->type] == false || (semantic_stacks->get_type($1->name) == TokenType::TOKEN_B && $3->type == TokenType::TOKEN_INT))
			{
				output::errorMismatch(yylineno);
				exit(2);
			}
			
			if($1->type == TokenType::TOKEN_B && $3->value > 255)
			{
				output::errorByteTooLarge(yylineno, std::to_string($3->value));
				exit(2);
			}

			semantic_stacks->set_value($1->name,$3->value);
			string place = $3->place== ""? to_string($3->value) : $3->place;
			 if ($1->type != TokenType::TOKEN_BOOL)
            {
                string target = "%var"+to_string(gen_code->current_var++);
                string name = "%var"+ gen_code->current_var++;
                gen_code->emit("store i32 "+place+" , i32* "+name);
                gen_code->emit(name + " = getelementptr [50 x i32], [50 x i32]* %fp, i32 0 , i32 " + to_string(semantic_table->get_entry($1->name)->offset));
                $$->next_list = $3->next_list;
            }
            else
            {
               string true_temp = "%var"+ to_string(gen_code->current_var++);
               string false_temp = "%var"+ to_string(gen_code->current_var++);

               int unused_index = gen_code->emit("br label @");
               string true_label = gen_code->genLabel();
               gen_code->bpatch(gen_code->makelist({unused_index, FIRST}), true_label);

               gen_code->emit(declare_var_llvm(true_temp, to_string(semantic_stacks->get_args_last_func()->size()), to_string(semantic_table->get_entry($1->name)->offset)));
               gen_code->emit("store i32 1 " , i32* " + true_temp);

               int true_index_patch = gen_code->emit("br label @");
               gen_code->bpatch($4->true_list, true_label);

               int false_label = gen_code->genLabel();
               gen_code->emit(declare_var_llvm(false_temp, to_string(semantic_stacks->get_args_last_func()->size()), to_string(semantic_table->get_entry($1->name)->offset)));
               gen_code->emit("store i32 0 " , i32* " + true_temp");

               int false_index_patch = gen_code->emit("br label @");
               gen_code->bpatch($3->false_list, false_label);

               $$->next_list = gen_code->merge(gen_code->makelist({true_index_patch, FIRST}), gen_code->makelist({false_index_patch, FIRST}));
             }
		}
		| Call SC {}
		| RETURN SC {
			if(semantic_stacks->get_func_type() != TokenType::TOKEN_UNDIF)
			{
				output::errorMismatch(yylineno);
				exit(2);
			}
			gen_code->emit("ret void")
			$$->return_statement=true;
		}

		| RETURN Exp M N M N M SC {
			if(convert_table[$2->type][semantic_stacks->get_func_type()] == TokenType::TOKEN_UNDIF || (semantic_stacks->get_func_type() == TokenType::TOKEN_B && $2->type == TokenType::TOKEN_INT))
			{
				output::errorMismatch(yylineno);
				exit(2);
			}
			semantic_stacks->update_last_func($2->value);
			$$->return_statement=true;
            if($2->type==TokenType::TOKEN_BOOL)
            {
                gen_code->bpatch($2->true_list,$3->quad);
                gen_code->bpatch($2->false_list,$5->quad);
                int buffer_index = gen_code->emit("br label @");
                int trueLabel = gen_code->genLabel();
                gen_code->bpatch(gen_code->makelist({buffer_index, FIRST}), trueLabel);
                int trueJump= gen_code->emit("ret i32 1");
                int falseLabel = gen_code->genLabel();
                int falseJump= gen_code->emit(r"ret i32 0");
                gen_code->bpatch($4->next_list,trueLabel);
                gen_code->bpatch($6->next_list,falseLabel);
            }
            else
            {
                gen_code->bpatch(gen_code->merge($4->next_list,$6->next_list),$7->quad);
                gen_code->emit("ret i32 " + $2->value);
                $$->next_list = $2->next_list;
            }
		}
		| IfExp M Statement {
               	        $$->quad=$2->quad;
               	        semantic_stacks->exit_scope();
               	        gen_code->bpatch($1->true_list, $$->quad);

                       $$->next_list = gen_code->merge($1->false_list, $3->next_list);
                       $$->continue_list = $3->continue_list;
                       $$->break_list = $3->break_list;
               	    } %prec NOELSE
		| IfExp M Statement ELSE N M { semantic_stacks->new_scope(); } Statement { semantic_stacks->exit_scope(); } %prec ELSE
		        {
		            gen_code->bpatch($1->true_list,$2->quad);
                    gen_code->bpatch($1->false_list,$6->quad);


                    $$->next_list = gen_code->merge($3->next_list, $7->next_list);
                    $$->next_list = gen_code->merge($$->next_list, $5->next_list);
                    $$->break_list = gen_code->merge($3->break_list, $7->break_list);
                    $$->continue_list = gen_code->merge($3->continue_list, $7->continue_list);
		        }
		| WHILE M LPAREN Exp RPAREN {
			if($3->type != TokenType::TOKEN_BOOL)
			{
				output::errorMismatch(yylineno);
				exit(2);
			}
			$$->true_list = $4->true_list;
            $$->false_list = $4->false_list;
            $$->quad = $2->quad;
			semantic_stacks->whilecounter++;
			semantic_stacks->new_scope();
			} M Statement {
			      gen_code->bpatch($4->true_list,$6->quad);


			      gen_code->bpatch($7->next_list, $2->quad);
                  gen_code->bpatch($7->continue_list, $2->quad);

                  $$->next_list = gen_code->merge($4->false_list, $7->break_list);

                  int label_index = gen_code->emit(br_loop_llvm($7->quad));
                  gen_code->bpatch(gen_code->makelist({label_index, FIRST}), $7->quad);
				semantic_stacks->whilecounter--;
				semantic_stacks->exit_scope();
			}
		| BREAK SC {
			if(semantic_stacks->whilecounter == 0)
			{
				output::errorUnexpectedBreak(yylineno);
				exit(2);
			}
			int label_index = gen_code->emit("br label @");
            $$->break_list = gen_code->makelist({label_index, FIRST});
		}
		| CONTINUE SC {
			if(semantic_stacks->whilecounter == 0)
			{
				output::errorUnexpectedContinue(yylineno);
				exit(2);
			}
			int label_index = gen_code->emit("br label @");

            $$->continue_list = gen_code->makelist({label_index, FIRST});
		}
		;
IfExp:  IF LPAREN Exp RPAREN {
		if($3->type != TokenType::TOKEN_BOOL)
		{
			output::errorMismatch(yylineno);
			exit(2);
		}
		semantic_stacks->new_scope();

	};
Call:	ID LPAREN ExpList M RPAREN {
			if(!semantic_stacks->is_exsists($1->name) || !semantic_stacks->is_func($1->name))
			{
				output::errorUndefFunc(yylineno,$1->name);
				exit(2);
			}

			vector<pair<TokenType,string>>* func_args = semantic_stacks->get_args($1->name);
			if(func_args->size() != $3->get_vars()->size())
			{
				output::errorPrototypeMismatch(yylineno,$1->name, *(semantic_stacks->get_string_args($1->name)));
				exit(2);
			}
			
			for(int i = 0; i < func_args->size(); i++)
			{
				if(convert_table[func_args->at(i).first][$3->get_vars()->at(i)->type] == TOKEN_UNDIF || (func_args->at(i).first == TokenType::TOKEN_B && $3->get_vars()->at(i)->type == TokenType::TOKEN_INT))
				{
					output::errorPrototypeMismatch(yylineno, $1->name, *(semantic_stacks->get_string_args($1->name)));
					exit(2);
				}
			}

			$$ = new Call(semantic_stacks->get_type($1->name), $1->name,semantic_stacks->get_value($1->name));
			gen_code->bpatch($3->true_list,$4->quad);
                  gen_code->bpatch($3->false_list,$4->quad);
                  if ($1->name == "print")
                    {
                      string str = $3->list->front()->name;
                      int str_len = to_string(str.length - 1);
                      gen_code->emit("call void @print (i8* getelementptr ([" + str_len + " x i8], [" + str_len + " x i8]* " + str + ", i32 0, i32 0))";);
                      return;
                    }
                    TokenType ret_type = semantic_stack->get_function_type($1->name);
                    string args_llvm = "";
                         for(int i=0; i<$3->size();i++)
                      {
                        args_llvm = args_llvm + "i32 " + $3->at(i)->value + ",";
                      }
                      /* Cut the last "," */
                      args = args_llvm.substr(0, args_llvm.length() - 1);
                      if(ret_type==TokenType::TOKEN_UNDIF)
                        {
                            int index=gen_code->emit("call void @" + name + "(" + args + ")");
                            gen_code->bpatch($3->false_list,to_string(index));
                            gen_code->bpatch($3->true_list,to_string(index));
                            gen_code->bpatch($3->next_list,to_string(index));
                        }
                      else
                        {
                            gen_code->emit("call i32 @" + name + "(" + args + ")");
							stinrg target = "%var"+to_string(gen_code->current_var++);
							gen_code->emit(assign_to_var_llvm(target, call_exp_llvm));
							$$->place=target;
							if (function_type == TokenType::TOKEN_BOOL)
							{
								string target_boolean = "%var"+to_string(gen_code->current_var++);
								gen_code->emit(target_boolean + " = icmp ne i32 0, " + $$->place);
								int label_index = gen_code->emit("br i1 " + target_boolean + " , label @ , label @");
								$$->true_list = gen_code->makelist({label_index, FIRST});
								$$->false_list = gen_code->makelist({label_index, SECOND});
							}
                        }


		}
		| ID LPAREN RPAREN {
			if(!semantic_stacks->is_exsists($1->name) || !semantic_stacks->is_func($1->name))
			{
				output::errorUndefFunc(yylineno,$1->name);
				exit(2);
			}
			vector<pair<TokenType,string>>* args=semantic_stacks->get_args($1->name);
			if(args->size()!=0)
			{
				output::errorPrototypeMismatch(yylineno,$1->name, *(semantic_stacks->get_string_args($1->name)));
				exit(2);
			}
			$$ = new Call(semantic_stacks->get_type($1->name), $1->name,semantic_stacks->get_value($1->name));

            TokenType ret_type = semantic_stack->get_function_type($1->name);
            string args_llvm = "";
                if(ret_type==TokenType::TOKEN_UNDIF)
                {
                    int index=gen_code->emit("call void @" + name + "()");
                }
                  else
                {
                    gen_code->emit("call i32 @" + name + "()");
                    string target = "%var"+to_string(gen_code->current_var++);
                    gen_code->emit(target + " = " + call_llvm);
                    $$->place=target;
                    if (function_type == TokenType::TOKEN_BOOL)
                {
                    string target_boolean = "%var"+to_string(gen_code->current_var++);
                    gen_code->emit(target_boolean + " = icmp ne i32 0, " + $$->place);
                    int label_index = gen_code->emit("br i1 " + target_boolean + " , label @ , label @");
                    $$->true_list = gen_code->makelist({label_index, FIRST});
                    $$->false_list = gen_code->makelist({label_index, SECOND});
                 }
            }


		}
		;

ExpList: Exp {
			ExpList *explist = new ExpList(); 
			explist->vars->push_back(Exp(*$1));
			$$ = explist;
            if ($1->type == TokenType::TOKEN_BOOL)
            {
                string target = "%var"+to_string(gen_code->current_var++);
                int unused_index = gen_code->emit("br label @");

                string true_label = gen_code->genLabel();
                gen_code->bpatch(BufferCode::makelist({unused_index, FIRST}), true_label);
                int true_index = gen_code->emit("br label @");
                gen_code->bpatch($1->true_list, true_label);

                string false_label =gen_code->genLabel();
                gen_code->bpatch(BufferCode::makelist({unused_index, FIRST}), false_label);
                int false_index = gen_code->emit("br label @");
                gen_code->bpatch($1->false_list, false_label);

                string next_label = gen_code->genLabel();
                gen_code->bpatch(gen_code->makelist({true_index, FIRST}), next_label);
                gen_code->bpatch(gen_code->makelist({false_index, FIRST}), next_label);
                gen_code->emit(target + " = phi i32 [ 1, %" + true_label + " ] , [ 0, %" + false_label + "]";
                $$->place = target;
            }
            $$->true_list=$1->true_list;
            $$->false_list=$1->false_list;
		}
		| Exp COMMA ExpList {
			Exp* exp = new Exp($1->type, $1->name, $1->value);
			$3->get_vars()->insert($3->get_vars()->begin(), Exp(*exp));
			$$ = $3;
			if ($1->type == TokenType::TOKEN_BOOL)
            {
                string target = "%var"+to_string(gen_code->current_var++);
                int unused_index = gen_code->emit("br label @");

                string true_label = gen_code->genLabel();
                gen_code->bpatch(BufferCode::makelist({unused_index, FIRST}), true_label);
                int true_index = gen_code->emit("br label @");
                gen_code->bpatch($1->true_list, true_label);

                string false_label =gen_code->genLabel();
                gen_code->bpatch(BufferCode::makelist({unused_index, FIRST}), false_label);
                int false_index = gen_code->emit("br label @");
                gen_code->bpatch($1->false_list, false_label);

                string next_label = gen_code->genLabel();
                gen_code->bpatch(gen_code->makelist({true_index, FIRST}), next_label);
                gen_code->bpatch(gen_code->makelist({false_index, FIRST}), next_label);
                gen_code->emit(target + " = phi i32 [ 1, %" + true_label + " ] , [ 0, %" + false_label + "]";
                $$->place = target;
            }
            $$->true_list = gen_code->merge($1->true_list, $3->true_list);
            $$->false_list = gen_code->merge($1->false_list, $3->false_list);
		}
		;

Type: INT {
		$$ = new Node(TokenType::TOKEN_INT, "", 0);
	}
	| BYTE {
		$$ = new Node(TokenType::TOKEN_B, "", 0);
	}
	| BOOL {
		$$ = new Node(TokenType::TOKEN_BOOL, "", 0);
	}
	;

Exp: LPAREN Exp RPAREN {
		$$ = new Exp($2->type, $2->name, $2->value);
		$$->true_list = $2->true_list;
		$$->false_list = $2->false_list;
		$$->break_list = $2->break_list;
		$$->continue_list = $2->continue_list;
		$$->next_list = $2->next_list;
	}
	| Exp IF N LPAREN Exp RPAREN ELSE Exp {
		if($4->type != TokenType::TOKEN_BOOL)
		{
			output::errorMismatch(yylineno);
			exit(2);
		}
		if(convert_table[$1->type][$8->type] == TokenType::TOKEN_UNDIF)
		{
			output::errorMismatch(yylineno);
			exit(2);
		}
		
		if($5->value == 1)
			$$ = new Exp($1->type, $1->name, $1->value);
		else
			$$ = new Exp($8->type, $8->name, $8->value);


            Node* jmp_to_end_label = new NMarkerNode();
            std::string to_start_label = gen_code->genLabel();

            NarkerNode* middle_jmp = new NMarkerNode();
            std::string middle_label = gen_code->genLabel();

            NarkerNode* jmp_to_bool_exp = new NMarkerNode();
            std::string end_label = gen_code->genLabelPhi();

            gen_code->bpatch($1->start_list, to_start_label);
            gen_code->bpatch($8->start_list, $8->start_label);
            gen_code->bpatch($5->true_list, $1->start_label);
            gen_code->bpatch($5->false_list, $8->start_label);
            gen_code->bpatch($5->start_list, $5->start_label);


            std::vector<pair<int, BranchLabelIndex>> all_jumps_to_end = gen_code->merge($3->next_list, jmp_to_end_label->next_list);
            gen_code->bpatch(all_jumps_to_end, end_label);
            gen_code->bpatch(jmp_to_bool_exp->next_list, $5->start_label);
            $$->place = "%var"+to_string(gen_code->current_var++);
            gen_code->bpatch($1->start_list, to_start_label);
            std::string phi_true_label = $1->trinary ? $1->start_label_tri: $1->start_label;
            std::string phi_false_label = $8->trinary ? $8->start_label_tri: $8->start_label;
            gen_code->emit($$->place +" = phi i32 [" + $1->place +", %" + phi_true_label + "] , [" + $8->place +  " , %" + phi_false_label+"]");
            $$->start_label_tri = end_label;
            $$->start_label = middle_label;
            $$->start_list = middle_jmp->next_list;
            $$->trinary = true;
	}


	| Exp PLUS Exp {
		TokenType new_type;
		int new_val;
		if($1->type==TokenType::TOKEN_STRING||$1->type==TokenType::TOKEN_BOOL||$3->type==TokenType::TOKEN_STRING||$3->type==TokenType::TOKEN_BOOL)
		{
			output::errorMismatch(yylineno);
			exit(2);
		}
		
		if($1->type == TokenType::TOKEN_INT || $3->type == TokenType::TOKEN_INT)
			new_type = TokenType::TOKEN_INT;
		else
			new_type = TokenType::TOKEN_B;
		
		if($2->name == "+")
			new_val = $1->value + $3->value;
		else if($2->name == "-")
			new_val = $1->value - $3->value;
		$$ = new Exp(new_type, std::to_string(new_val), new_val);


		string target = "%var"+to_string(gen_code->current_var++);

        string right_place = $3->place;
        string left_place = $1->place;

        /* The values to use */
        string right = right_place == "" ? right_value : right_place;
        string left = left_place == "" ? left_value : left_place;

        bool can_overflow = false;
        /* Byte overflow */
        if ($1->type == TokenType::TOKEN_B && $3->type == TokenType::TOKEN_B)
		{

			string left_var = "%var"+to_string(gen_code->current_var++);
			gen_code->emit(left_var + " = trunc i32 " + $1->value + " to i8");

			string right_var = "%var"+to_string(gen_code->current_var++);
			gen_code->emit(right_var + " = trunc i32 " + $1->value + " to i8");

			/* Bubble the updates */
			left = left_var;
			right = right_var;

			can_overflow = true;
		}

		string op_type_llvm = can_overflow ? "i8" : "i32";
		else if (op == "+")
		{
		gen_code->emit(target + " = add" + op_type_llvm+ " " left+ ", " right););
		}
		else if (op == "-")
		{
			gen_code->emit(target + " = sub" + op_type_llvm+ " " left+ ", " right););
		}

		/* Handle overflow / sign */
		if (can_overflow)
		{
			string next_var = "%var"+to_string(gen_code->current_var++);
			gen_code->emit(next_var + " = zext i8 " + target + " to i32");
			target = next_var;
		}
		$$->place = target;
	}
	| Exp MULTI Exp  {
		TokenType new_type;
		int new_val;
		if($1->type == TokenType::TOKEN_STRING || $1->type == TokenType::TOKEN_BOOL || $3->type == TokenType::TOKEN_STRING || $3->type == TokenType::TOKEN_BOOL)
		{
			output::errorMismatch(yylineno);
			exit(2);
		}
		
		if($1->type == TokenType::TOKEN_INT || $3->type == TokenType::TOKEN_INT)
			new_type = TokenType::TOKEN_INT;
		else
			new_type = TokenType::TOKEN_B;
		
		if($2->name == "*")
			new_val = $1->value * $3->value;
		else if($2->name == "/")
		{
			new_val = $1->value / $3->value;
		}
		$$ = new Exp(new_type, std::to_string(new_val), new_val);


          string target = "%var"+to_string(gen_code->current_var++);

          string right_place = $3->place;
          string left_place = $1->place;

          string right = right_place == "" ? right_value : right_place;
          string left = left_place == "" ? left_value : left_place;

          bool can_overflow = false;
          if ($2->name != "/" && $1->type == TokenType::TOKEN_B && $3->type == TokenType::TOKEN_B)
          {

            string left_var = "%var"+to_string(gen_code->current_var++);
            gen_code->emit(left_var + " = trunc i32 " + $1->value + " to i8");

            string right_var = "%var"+to_string(gen_code->current_var++);
            gen_code->emit(right_var + " = trunc i32 " + $1->value + " to i8");

            /* Bubble the updates */
            left = left_var;
            right = right_var;

            can_overflow = true;
          }

          string op_type_llvm = can_overflow ? "i8" : "i32";

          if (op == DIV)
          {
            string zero_var_llvm = "%var"+to_string(gen_code->current_var++);
            string zero_source = right_place == "" ? right_value : right_place;

            gen_code->emit(zero_var_llvm + " = icmp eq i32 " + zero_source + ", 0");
            int zero_bp = gen_code->emit("br i1 " + zero_var_llvm + " , label @ , label @");

            string error_label = gen_code->genLabel();
            gen_code->emit("call i32 (i8*, ...) @printf(i8* getelementptr([24 x i8], [24 x i8]* @.zero_div, i32 0, i32 0))
                    call void @exit(i32 0)");

            int unused_bp = gen_code->emit("br label @");

            string success_label = gen_code->genLabel();
            gen_code->emit(target + " = sdiv" + op_type_llvm+ " " left+ ", " right);
            gen_code->bpatch(gen_code->makelist({zero_bp, SECOND}), success_label);
            gen_code->bpatch(gen_code->makelist({zero_bp, FIRST}), error_label);
            gen_code->bpatch(gen_code->makelist({unused_bp, FIRST}), success_label);
          }
          else if (op == "*")
          {
            gen_code->emit(target + " = mul" + op_type_llvm+ " " left+ ", " right););
          }

          /* Handle overflow / sign */
          if (can_overflow)
          {
            string next_var = "%var"+to_string(gen_code->current_var++);
            gen_code->emit(next_var + " = zext i8 " + target + " to i32");
            target = next_var;
          }
          $$->place = target;
        }
	}
	| ID  {

		if(semantic_stacks->is_func($1->name))
		{
			output::errorUndef(yylineno,$1->name);
			exit(2);
		}

		TokenType type = semantic_stacks->get_type($1->name);
		
		if(TOKEN_UNDIF==type)
		{
			output::errorUndef(yylineno, $1->name);
			exit(2);
		}

		$$ = new Exp(type, $1->name, semantic_stacks->get_value($1->name));
        string source = "%var"+to_string(gen_code->current_var++);
        string target = "%var"+to_string(gen_code->current_var++);

        int size_of_args = semantic_table->get_args_last_func()->size();

        table_entry * entry=semantic_table->get_entry($1->name);

          gen_code->emit(declare_var_llvm(source, args_size_str, id_offset));
          gen_code->emit(target + " = load i32, i32* " + source;);
          $$->place = target;

          if (entry->type == TokenType::TOKEN_BOOL)
          {
            int target_boolean = "%var"+to_string(gen_code->current_var++);
            gen_code->emit(target_boolean + " = icmp ne i32 0, " + source);
            int branch_index = gen_code->emit("br i1 " + target_boolean + " , label @ , label @");
            auto unconditional_list = gen_code->makelist({branch_index, FIRST});
            auto conditional_list = gen_code->makelist({branch_index, SECOND});

            $$->true_list = unconditional_list;
            $$->false_list = conditional_list;
          }
	}
	| Call {}
	| NUM {
		$$->type = $1->type;
        $$->value = $1->value;
	}
	| NUM B {
		$$->type = TokenType::TOKEN_B;
      	$$->value = $1->value;
      	if ($1->value > 255)
		{
        	output::errorByteTooLarge(yylineno, std::to_string($1->value)); 
			exit(2);
		}
	}
	| STRING {
		$$ = new Exp($1->type, $1->name, $1->value);
	}
	| TRUE  {
		$$ = new Exp(TokenType::TOKEN_BOOL, "TRUE",1);
		int label_index = gen_code->emit("br label @");
        $$->true_list = gen_code->makelist({label_index, FIRST});
	}
	| FALSE  {
		$$ = new Exp(TokenType::TOKEN_BOOL, "FALSE",0);
		int label_index = gen_code->emit("br label @");
        $$->false_list = gen_code->makelist({label_index, FIRST});
	}
	| NOT Exp  {
		if($2->value == 0) 
			$$ = new Exp($2->type, "TRUE", 1);
		else 
			$$ = new Exp($2->type, "FALSE", 0);
		string flippedBool = "%var"+to_string(gen_code->current_var++);
        string newPlace = "%var"+to_string(gen_code->current_var++);
        gen_code->emit(flippedBool + " = icmp ne i32 1, " + $2->place);
        gen_code->emit(newPlace + "= zext " + flippedBool +" i1 to i32");
        $$->place=newPlace;
        $$->true_list=$2->false_list;
        $$->false_list=$2->true_list;
	}
	| Exp AND M Exp  {
		if($1->type != TokenType::TOKEN_BOOL || $4->type != TokenType::TOKEN_BOOL)
		{
			output::errorMismatch(yylineno);
			exit(2);
		}

		int new_val = $1->value & $4->value;
		if(new_val == 0)
			$$ = new Exp($1->type, "FALSE", new_val);
		else 
			$$ = new Exp($1->type, "TRUE", new_val);
		$$->quad=$3->quad;
		gen_code->bpatch($1->true_list, $$->quad);
        $$->true_list = $4->true_list;
        $$->false_list = gen_code->merge($1->false_list, $4->false_list);
		}
		| Exp OR M Exp  {
			if($1->type != TokenType::TOKEN_BOOL || $4->type != TokenType::TOKEN_BOOL)
			{
				output::errorMismatch(yylineno);
				exit(2);
			}
			
			int new_val = $1->value | $4->value;
			if(new_val == 0) 
				$$ = new Exp($1->type, "FALSE", new_val);
			else 
				$$ = new Exp($1->type, "TRUE", new_val);

			gen_code->bpatch($1->false_list, $$->quad);
            $$->false_list = $4->false_list;
            $$->true_list = gen_code->merge($1->true_list, $4->true_list);
		}		
		| Exp RELOP Exp  {
			# Mismatch check
			if($1->type == TokenType::TOKEN_UNDIF || $1->type == TokenType::TOKEN_BOOL || $1->type == TokenType::TOKEN_STRING ||
				$3->type == TokenType::TOKEN_UNDIF || $3->type == TokenType::TOKEN_STRING || $3->type == TokenType::TOKEN_BOOL)
			{
				output::errorMismatch(yylineno);
				exit(2);
			}

			# Value update
			int new_val;
			if($2->name == "==")
				new_val = $1->value == $3->value;
			if($2->name == "!=")
				new_val = $1->value != $3->value;
			if($2->name == "<")
				new_val = $1->value < $3->value;
			if($2->name == ">")
				new_val = $1->value > $3->value;
			if($2->name == "<=")
				new_val = $1->value <= $3->value;
			if($2->name == ">=")
				new_val = $1->value >= $3->value;

			if(new_val == 1) 
				$$ = new Exp(TokenType::TOKEN_BOOL, "TRUE", new_val);
			else 
				$$ = new Exp(TokenType::TOKEN_BOOL, "FALSE", new_val);

			string right_value = to_string($3->value);
            string left_value = to_string($1->value);

            /* The values to use */
    		string right = right_place == "" ? right_value : right_place;
            to_string left = left_place == "" ? left_value : left_place;
            string op_llvm = "eq"; /* == */

            if ($2->name == ">")
            {
            	op_llvm = "sgt";
            }
            else if ($2->name == ">=")
            {
                op_llvm = "sge";
            }
            else if ($2->name == "<")
            {
                op_llvm = "slt";
            }
            else if ($2->name == "<=")
            {
                op_llvm = "sle";
            }
            else if ($2->name == "!=")
            {
                op_llvm = "ne";
            }
            string target = "%var"+to_string(gen_code->current_var++);
            string finalRes = "%var"+to_string(gen_code->current_var++);
            gen_code->emit(target + " = icmp " + op_llvm + " i32 " + left + ", " + right;);

            int label_index = gen_code->emit("br i1 " + target + " , label @ , label @");
            gen_code->emit(finalRes + " = zext i8 " + target + " to i32");

            $$->true_list = BufferCode::makelist({label_index, FIRST});
            $$->false_list = BufferCode::makelist({label_index, SECOND});
            $$->place = finalRes;		
	}
	| LPAREN Type RPAREN Exp %prec CAST   {
		if(convert_table[$2->type][$4->type] == TokenType::TOKEN_UNDIF)
		{
			output::errorMismatch(yylineno);
			exit(2);
		}
		if($2->type == TokenType::TOKEN_BOOL) 
			{
			    $$ = $4;
			}
		if($2->type == TokenType::TOKEN_INT)
			{
			    $$ = new Exp($2->type,$4->name,$4->value);
			    if($4->type==TokenType::TOKEN_B)
			    {
			         string next_var = "%var"+to_string(gen_code->current_var++);();
                     gen_code->emit(next_var + " = zext i8 " + target + " to i32");
                     $$->place = next_var;
			    }
			}
		if($2->type == TokenType::TOKEN_B)
		{
			if($4->type == TokenType::TOKEN_INT && $4->value > 255) 
			{
				output::errorByteTooLarge(yylineno, std::to_string($4->value));
				exit(2);
			}
			$$ = new Exp($2->type,$4->name,$4->value);
			string next_var = "%var"+to_string(gen_code->current_var++);
			gen_code->emit(next_var + " = trunc i32 " + $4->value + " to i8");
			$$->place = next_var;
		}
	}
	;


%%

int yyerror(const char* const s)
{
  extern int yylineno;
  output::errorSyn(yylineno);
  exit(2);
}

int main(){
//yydebug=1;
     int ret= yyparse();
	gen_code->emitGlobal(printf_llvm);
    gen_code->emitGlobal(zero_div_llvm);
    gen_code->emitGlobal(printi_llvm);

    gen_code->emitGlobal(print_llvm);
    gen_code->emitGlobal(exit_llvm);

    gen_code->printGlobalBuffer();
    gen_code->printCodeBuffer();
    return ret;
}

