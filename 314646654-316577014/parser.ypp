%{
#include <iostream>
#include "llvm.h"
#include "parser.hpp"
#include "hw3_output.hpp"
#include "bp.hpp"
#include <climits>
extern int yylineno;
using namespace std;
int yyerror(const char * const s);
int yylex(void);
Stacks* semantic_stacks;
#define YYDEBUG 1
#pragma GCC diagnostic ignored "-Wfree-nonheap-object"
#define gen_code (CodeBuffer::instance())

TokenType convert_table[5][5]={
        {/*UNDIF TO*/
                /*TOKEN_UNDIF*/TOKEN_UNDIF,
                /*TOKEN_INT*/TOKEN_UNDIF,
                /*TOKEN_B*/TOKEN_UNDIF,
                /*TOKEN_BOOL*/TOKEN_UNDIF,
                /*TOKEN_STRING*/TOKEN_UNDIF
        },
        {/*INT TO*/
                /*TOKEN_UNDIF*/TOKEN_UNDIF,
                /*TOKEN_INT*/TOKEN_INT,
                /*TOKEN_B*/TOKEN_INT,
                /*TOKEN_BOOL*/TOKEN_UNDIF,/*not sure*/
                /*TOKEN_STRING*/TOKEN_UNDIF
        },
        {/*B TO*/
                /*TOKEN_UNDIF*/TOKEN_UNDIF,
                /*TOKEN_INT*/TOKEN_INT,
                /*TOKEN_B*/TOKEN_B,
                /*TOKEN_BOOL*/TOKEN_UNDIF,
                /*TOKEN_STRING*/TOKEN_UNDIF
        },
        {/*BOOL TO*/
                /*TOKEN_UNDIF*/TOKEN_UNDIF,
                /*TOKEN_INT*/TOKEN_UNDIF,
                /*TOKEN_B*/TOKEN_UNDIF,
                /*TOKEN_BOOL*/TOKEN_BOOL,
                /*TOKEN_STRING*/TOKEN_UNDIF
        },
        {/*STRING TO*/
                /*TOKEN_UNDIF*/TOKEN_UNDIF,
                /*TOKEN_INT*/TOKEN_UNDIF,
                /*TOKEN_B*/TOKEN_UNDIF,
                /*TOKEN_BOOL*/TOKEN_UNDIF,
                /*TOKEN_STRING*/TOKEN_STRING
        }
};


%}

%token VOID INT BYTE B BOOL TRUE FALSE RETURN WHILE BREAK CONTINUE SC COMMA LBRACE RBRACE ID NUM STRING
%right ASSIGN
%left OR
%left AND
%nonassoc RELOP
%left PLUS
%left MULTI
%left NOT
%right RPAREN
%right LPAREN

%nonassoc NOELSE
%nonassoc ELSE

%nonassoc IF
%nonassoc CAST
%token YYEOF
%%

Program:   
		{ semantic_stacks=new Stacks();}
		Funcs YYEOF {
			if(!semantic_stacks->is_exsists("main") || !semantic_stacks->is_func("main") || semantic_stacks->get_type("main") != TokenType::TOKEN_UNDIF || semantic_stacks->get_args("main")->size()!=0)
			{
				output::errorMainMissing();
				exit(2);
			}
		 //semantic_stacks->exit_scope();
		  }
		;

Funcs: 
	%empty  
	| FuncDecl Funcs {}
		;

FuncDecl: 
		RetType ID LPAREN Formals RPAREN  {
			if(semantic_stacks->is_exsists($2->name))
			{
				output::errorDef(yylineno,$2->name);
				exit(2);
			}

			for(int i=0; i<$4->get_args()->size();i++)
			{
				if($4->get_args()->at(i).second == $2->name)
				{
					output::errorDef(yylineno,$2->name);
					exit(2);
				}
			}

			semantic_stacks->new_func($2->name,$1->type,$4->get_args());
			string type_in_str = $1->type==TokenType::TOKEN_UNDIF ? "void" : "i32";
            string args = "";
            for (auto i = 0; i < $4->get_args()->size(); i++)
            {
                args = args + "i32 ,";
            }
            args = args.substr(0, args.length() - 1);
			gen_code.emit("define " + type_in_str + " @" + $2->name + "(" + args + ") {");
			gen_code.emit("entry:");
			gen_code.emit("%fp = alloca [50 x i32]");

			int args_num = $4->get_args()->size();
			if (args_num > 0)
			{
				gen_code.emit("%args = alloca [" + to_string(args_num) + " x i32]");
			}
			for (auto i = 0; i < args_num; i++)
			{
				string target = "%var"+ to_string(gen_code.current_var++);
				int pointer = (i + 1) * (-1);
				gen_code.emit("\n" + target + (pointer >= 0 ? " = getelementptr [50 x i32], [50 x i32]* %fp, i32 0 , i32 " + to_string(pointer) : " = getelementptr [" + to_string(args_num) + " x i32], [" + to_string(args_num) + " x i32]* %args, i32 0 , i32 " + to_string(((pointer + 1) * (-1)))));
				gen_code.emit("store i32 %" + to_string(i) + " , i32* " + target);
				
			}
		}
            LBRACE Statements RBRACE {
				int buffer_index = gen_code.emit("br label @");
          		string label = gen_code.genLabel();
          		gen_code.bpatch(gen_code.makelist({buffer_index, FIRST}), label);
				int index = gen_code.emit($1->type == TokenType::TOKEN_UNDIF ? ret_void_llvm : ret_success_llvm);
				gen_code.bpatch($8->next_list,label);
            	semantic_stacks->exit_scope();gen_code.emit("}");
            }
		;

RetType:		
		Type { $$ = $1; }
		| VOID { $$ = new Node(TokenType::TOKEN_UNDIF,"",0); }
		;

Formals:		
		%empty { $$ = new FormalList();}
		| FormalsList { $$ = $1; }
		;
FormalsList:	
			FormalDecl {if(semantic_stacks->is_exsists($1->name)){output::errorDef(yylineno,$1->name); exit(2);}$$ = new FormalList(); $$->get_args()->insert($$->get_args()->begin(),pair<TokenType,string>($1->type,$1->name));}
			| FormalDecl COMMA FormalsList 
			{
				vector<pair<TokenType,string>>* args = $3->get_args();
				for(int i=0;i<args->size();i++)
					if(args->at(i).second == $1->name)
					{
						output::errorDef(yylineno,$1->name);
						exit(2);
					}
				if(semantic_stacks->is_exsists($1->name))
				{
					output::errorDef(yylineno,$1->name);
					exit(2);
				}
				$3->get_args()->insert($3->get_args()->begin(),pair<TokenType,string>($1->type,$1->name));
				$$ = $3;
			}
			;

FormalDecl: 	
			Type ID { $$ = new Node($1->type,$2->name,0); }
		;
Statements:	
			Statement {
			$$=new Node();
			$$->next_list = $1->next_list;
            $$->break_list = $1->break_list;
            $$->continue_list = $1->continue_list;
			$$->next_list = $1->next_list;
			gen_code.bpatch($1->start_list, $1->start_label);
            }
			| Statements M Statement
			{
                if ($3->return_statement == false)
                {
                    gen_code.bpatch($1->next_list, $2->quad);
                }
				gen_code.bpatch($1->next_list, $2->quad);
                $$=new Node();
                $$->next_list = $3->next_list;
                $$->break_list = gen_code.merge($1->break_list,$3->break_list);
                $$->continue_list = gen_code.merge($1->continue_list,$3->continue_list);
                gen_code.bpatch($3->start_list, $3->start_label);

            }
		;

M:
    %empty                            
	{
          int buffer_index = gen_code.emit("br label @");
          string label = gen_code.genLabel();
          gen_code.bpatch(gen_code.makelist({buffer_index, FIRST}), label);
          $$=new Node();
          $$->quad = label;
    };

N:
    %empty                            
	{
        int buffer_index = gen_code.emit("br label @");
        string label = gen_code.genLabel();
        gen_code.bpatch(gen_code.makelist({buffer_index, FIRST}), label);
        $$=new Node();
        $$->quad = label;
       	$$->next_list = gen_code.makelist({gen_code.emit("br label @"), FIRST});
    };

Statement:	
		LBRACE {

		    semantic_stacks->new_scope();
		}
		Statements M RBRACE
		{
             $$ = new Node();
             $$->next_list = $3->next_list;
             $$->break_list = $3->break_list;
             $$->continue_list = $3->continue_list;
             gen_code.bpatch($3->next_list,$4->quad);
             gen_code.bpatch($$->start_list,$$->start_label);
            semantic_stacks->exit_scope();
		}

		| Type ID SC {
			if(semantic_stacks->is_exsists($2->name))
			{
				output::errorDef(yylineno,$2->name);
				exit(2);
			}
			$$ = new Node($1->type, $2->name, 0);
			semantic_stacks->new_entry($2->name,$1->type,0);
			string name = "%var"+ to_string(gen_code.current_var++);
            gen_code.emit(name + " = getelementptr [50 x i32], [50 x i32]* %fp, i32 0 , i32 " + to_string(semantic_stacks->get_entry($2->name)->offset));
			gen_code.emit("store i32 0 , i32* "+name);
		}
		| Type ID ASSIGN Exp SC {
			if(semantic_stacks->is_exsists($2->name))
			{
				output::errorDef(yylineno,$2->name);
				exit(2);
			}

			if(convert_table[$1->type][$4->type] == false || ($1->type == TokenType::TOKEN_B && $4->type == TokenType::TOKEN_INT))
			{
			fflush(stdout);
				output::errorMismatch(yylineno);
				exit(2);
			}
			
			if($2->type == TokenType::TOKEN_B && $4->value > 255)
			{
				output::errorByteTooLarge(yylineno, std::to_string($3->value));
				exit(2);
			}
			
			$$ = new Node($1->type,$2->name,$4->value);
			semantic_stacks->new_entry($2->name,$1->type,$4->value);

			string place = $4->place== ""? to_string($4->value) : $4->place;


            if ($4->type != TokenType::TOKEN_BOOL)
            {
				if ($4->type == TokenType::TOKEN_B)
				{
					string temp = "%var"+ to_string(gen_code.current_var++);
					gen_code.emit(temp + " = zext i8 " + place + " to i32");
					//$4->place = temp;
					place = temp;
				}
                string target = "%var"+to_string(gen_code.current_var++);
                string name = "%var"+ to_string(gen_code.current_var++);
                gen_code.emit(name + " = getelementptr [50 x i32], [50 x i32]* %fp, i32 0 , i32 " + to_string(semantic_stacks->get_entry($2->name)->offset));
                gen_code.emit("store i32 " + place + " , i32* "+name);
                $$->next_list = $4->next_list;
            }
            else
            {
               string true_temp = "%var"+ to_string(gen_code.current_var++);
               string false_temp = "%var"+ to_string(gen_code.current_var++);

               int unused_index = gen_code.emit("br label @");
               string true_label = gen_code.genLabel();
               gen_code.bpatch(gen_code.makelist({unused_index, FIRST}), true_label);

               gen_code.emit(declare_var_llvm(true_temp, "0", semantic_stacks->get_entry($2->name)->offset));
               gen_code.emit("store i32 1 , i32* " + true_temp);

               int true_index_patch = gen_code.emit("br label @");
               gen_code.bpatch($4->true_list, true_label);

               string false_label = gen_code.genLabel();
               gen_code.emit(declare_var_llvm(false_temp, "0", semantic_stacks->get_entry($2->name)->offset));
               gen_code.emit("store i32 0 , i32* " + false_temp);

               int false_index_patch = gen_code.emit("br label @");
               gen_code.bpatch($4->false_list, false_label);

               $$->next_list = gen_code.merge(gen_code.makelist({true_index_patch, FIRST}), gen_code.makelist({false_index_patch, FIRST}));
			   $$->next_list = gen_code.merge($$->next_list,$4->next_list);
             }
			 gen_code.bpatch($4->start_list, $4->start_label);
        }
		| ID ASSIGN Exp SC {
			if(!semantic_stacks->is_exsists($1->name) || semantic_stacks->is_func($1->name))
			{
				output::errorUndef(yylineno,$1->name);
				exit(2);
			}

			if(convert_table[semantic_stacks->get_type($1->name)][$3->type] == false || (semantic_stacks->get_type($1->name) == TokenType::TOKEN_B && $3->type == TokenType::TOKEN_INT))
			{
				output::errorMismatch(yylineno);
				exit(2);
			}
			
			if($1->type == TokenType::TOKEN_B && $3->value > 255)
			{
				output::errorByteTooLarge(yylineno, std::to_string($3->value));
				exit(2);
			}
            $$=new Node();
			semantic_stacks->set_value($1->name,$3->value);
			string place = $3->place== ""? to_string($3->value) : $3->place;
			if ($3->type != TokenType::TOKEN_BOOL)
            {
                if($3->type==TokenType::TOKEN_B)
                {
                    string new_var = "%var"+to_string(gen_code.current_var++);
                    gen_code.emit(new_var + " = zext i8 " + place + " to i32");
                    place=new_var;
                    //$3->place=new_var;
                }
                string target = "%var"+to_string(gen_code.current_var++);
                string name = "%var"+ to_string(gen_code.current_var++);
                gen_code.emit(name + " = getelementptr [50 x i32], [50 x i32]* %fp, i32 0 , i32 " + to_string(semantic_stacks->get_entry($1->name)->offset));
                gen_code.emit("store i32 "+place+" , i32* "+name);
				$$->next_list = $3->next_list;
            }
            else
            {
               	string true_temp = "%var"+ to_string(gen_code.current_var++);
               	string false_temp = "%var"+ to_string(gen_code.current_var++);

               	int unused_index = gen_code.emit("br label @");
               	string true_label = gen_code.genLabel();
               	gen_code.bpatch(gen_code.makelist({unused_index, FIRST}), true_label);

               	gen_code.emit(declare_var_llvm(true_temp, to_string(semantic_stacks->get_args_last_func()->size()), semantic_stacks->get_entry($1->name)->offset));
               	gen_code.emit("store i32 1 , i32* " + true_temp);

              	int true_index_patch = gen_code.emit("br label @");
               	gen_code.bpatch($3->true_list, true_label);

               	string false_label = gen_code.genLabel();
               	gen_code.emit(declare_var_llvm(false_temp, to_string(semantic_stacks->get_args_last_func()->size()), semantic_stacks->get_entry($1->name)->offset));
               	gen_code.emit("store i32 0 , i32* " + false_temp);

               	int false_index_patch = gen_code.emit("br label @");
               	gen_code.bpatch($3->false_list, false_label);
               	$$->next_list = gen_code.merge(gen_code.makelist({true_index_patch, FIRST}), gen_code.makelist({false_index_patch, FIRST}));
				$$->next_list = gen_code.merge($$->next_list,$3->next_list);
			 }
			 gen_code.bpatch($3->start_list, $3->start_label);
		}
		| Call SC {
			$$=$1;

			$$->next_list = gen_code.merge(gen_code.merge($$->true_list,$$->false_list),$$->next_list);
		}
		| RETURN SC {
			if(semantic_stacks->get_func_type() != TokenType::TOKEN_UNDIF)
			{
				output::errorMismatch(yylineno);
				exit(2);
			}
			gen_code.emit("ret void");
			$$=new Exp(TokenType::TOKEN_UNDIF,"",0);
			$$->return_statement=true;
			gen_code.bpatch($$->start_list, $$->start_label);
		}

		| RETURN Exp M N M N M SC {
			if(convert_table[$2->type][semantic_stacks->get_func_type()] == TokenType::TOKEN_UNDIF || (semantic_stacks->get_func_type() == TokenType::TOKEN_B && $2->type == TokenType::TOKEN_INT))
			{
				output::errorMismatch(yylineno);
				exit(2);
			}
			semantic_stacks->update_last_func($2->value);
			$$=$2;//not sure if maybe new node
			$$->return_statement=true;
            if($2->type==TokenType::TOKEN_BOOL)
            {
                gen_code.bpatch($2->true_list,$3->quad);
                gen_code.bpatch($2->false_list,$5->quad);
                int buffer_index = gen_code.emit("br label @");
                string trueLabel = gen_code.genLabel();
                gen_code.bpatch(gen_code.makelist({buffer_index, FIRST}), trueLabel);
                int trueJump= gen_code.emit("ret i32 1");
                string falseLabel = gen_code.genLabel();
                int falseJump= gen_code.emit("ret i32 0");
                gen_code.bpatch($4->next_list,trueLabel);
                gen_code.bpatch($6->next_list,falseLabel);
            }
            else
            {
				string value = $2->place == "" ? to_string($2->value) : $2->place;
                gen_code.bpatch(gen_code.merge($4->next_list,$6->next_list),$7->quad);
                if($2->type==TokenType::TOKEN_B)
                {
                    string new_var = "%var"+to_string(gen_code.current_var++);
                    gen_code.emit(new_var + " = zext i8 " + value + " to i32");
                    value=new_var;
                }
                gen_code.emit("ret i32 " + value);
                $$->next_list = $2->next_list;
            }
			gen_code.bpatch($2->start_list, $2->start_label);
		}
		| IfExp M Statement
		{
		    $$=new Node();
            $$->quad=$2->quad;
            semantic_stacks->exit_scope();
            gen_code.bpatch($1->true_list, $$->quad);

           $$->next_list = gen_code.merge($1->false_list, $3->next_list);
		   $$->next_list = gen_code.merge($$->next_list,$1->next_list); // Not sure if necesery
           $$->continue_list = $3->continue_list;
           $$->break_list = $3->break_list;
           gen_code.bpatch($1->start_list, $1->start_label);
		   gen_code.bpatch($3->start_list, $3->start_label);
        } %prec NOELSE
		| IfExp M Statement ELSE N M Statement %prec ELSE
		        {
		            $$=new Node();
		            gen_code.bpatch($1->true_list,$2->quad);
                    gen_code.bpatch($1->false_list,$6->quad);


                    $$->next_list = gen_code.merge($3->next_list, $7->next_list);
                    $$->next_list = gen_code.merge($$->next_list, $5->next_list);
					$$->next_list = gen_code.merge($$->next_list,$1->next_list); // Not sure if necesery
                    $$->break_list = gen_code.merge($3->break_list, $7->break_list);
                    $$->continue_list = gen_code.merge($3->continue_list, $7->continue_list);
                    gen_code.bpatch($1->start_list, $1->start_label);
                    gen_code.bpatch($7->start_list, $7->start_label);
                    gen_code.bpatch($3->start_list, $3->start_label);
                    semantic_stacks->exit_scope();
		        }
		| WHILE M LPAREN Exp RPAREN {

			if($4->type != TokenType::TOKEN_BOOL)
			{
				output::errorMismatch(yylineno);
				exit(2);
			}

			semantic_stacks->whilecounter++;
			semantic_stacks->new_scope();
			} M Statement {
                $$=new Node();
                $$->true_list = $4->true_list;
                $$->false_list = $4->false_list;
                $$->quad = $2->quad;
			    gen_code.bpatch($4->true_list,$7->quad);


			    gen_code.bpatch($8->next_list, $2->quad);
                gen_code.bpatch($8->continue_list, $2->quad);

                $$->next_list = gen_code.merge($4->false_list, $8->break_list);
				$$->next_list = gen_code.merge($$->next_list,$4->next_list); // Not sure if necesery

                int label_index = gen_code.emit(br_loop_llvm($2->quad));
                gen_code.bpatch(gen_code.makelist({label_index, FIRST}), $8->quad);
				semantic_stacks->whilecounter--;
				semantic_stacks->exit_scope();
				gen_code.bpatch($4->start_list, $4->start_label);
				gen_code.bpatch($8->start_list, $8->start_label);
			}
			
		| BREAK SC {
			if(semantic_stacks->whilecounter == 0)
			{
				output::errorUnexpectedBreak(yylineno);
				exit(2);
			}
			$$=new Node();
			int label_index = gen_code.emit("br label @");
            $$->break_list = gen_code.makelist({label_index, FIRST});
		}
		| CONTINUE SC {
			if(semantic_stacks->whilecounter == 0)
			{
				output::errorUnexpectedContinue(yylineno);
				exit(2);
			}
			int label_index = gen_code.emit("br label @");
            $$=new Node();
            $$->continue_list = gen_code.makelist({label_index, FIRST});
		}
		;
IfExp:  IF LPAREN Exp RPAREN {
		if($3->type != TokenType::TOKEN_BOOL)
		{
		    fflush(stdout);
			output::errorMismatch(yylineno);
			exit(2);
		}
		semantic_stacks->new_scope();
        gen_code.bpatch($3->start_list, $3->start_label);
        $$=$3;
	};
Call:	ID LPAREN ExpList M RPAREN {
			if(!semantic_stacks->is_exsists($1->name) || !semantic_stacks->is_func($1->name))
			{
				output::errorUndefFunc(yylineno,$1->name);
				exit(2);
			}

			vector<pair<TokenType,string>>* func_args = semantic_stacks->get_args($1->name);
			if(func_args->size() != $3->get_vars()->size())
			{
				output::errorPrototypeMismatch(yylineno,$1->name, *(semantic_stacks->get_string_args($1->name)));
				exit(2);
			}
			
			for(int i = 0; i < func_args->size(); i++)
			{
				if(convert_table[func_args->at(i).first][$3->get_vars()->at(i).type] == TokenType::TOKEN_UNDIF || (func_args->at(i).first == TokenType::TOKEN_B && $3->get_vars()->at(i).type == TokenType::TOKEN_INT))
				{
					output::errorPrototypeMismatch(yylineno, $1->name, *(semantic_stacks->get_string_args($1->name)));
					exit(2);
				}
			}

			$$ = new Call(semantic_stacks->get_type($1->name), $1->name,semantic_stacks->get_value($1->name));
			//gen_code.bpatch($3->true_list,$4->quad);
            //gen_code.bpatch($3->false_list,$4->quad);
            if ($1->name == "print")
            {
                string str = $3->get_vars()->front().place;
                string str_len = to_string($3->get_vars()->front().name.length() - 1);
                gen_code.emit("call void @print (i8* getelementptr ([" + str_len + " x i8], [" + str_len + " x i8]* " + str + ", i32 0, i32 0))");
            }
            else
            {
                TokenType ret_type = semantic_stacks->get_func_type($1->name);
                string args_llvm = "";
                for(int i=0; i<$3->get_vars()->size();i++)
                {
					if ($3->get_vars()->at(i).place != "")
					{
					    if(semantic_stacks->get_entry($3->get_vars()->at(i).name)==nullptr)
					    {
					        if($3->get_vars()->at(i).type==TokenType::TOKEN_B)
					        {
					            string new_var = "%var"+to_string(gen_code.current_var++);
					            gen_code.emit(new_var + " = zext i8 " + $3->get_vars()->at(i).place + " to i32");
					            args_llvm = args_llvm + "i32 " + new_var + ",";
					        }
					        else
					        {
					        args_llvm = args_llvm + "i32 " + $3->get_vars()->at(i).place + ",";
					        }
					        continue;
					    }
					    else
					    {
                            string source = "%var"+to_string(gen_code.current_var++);
                            string target = "%var"+to_string(gen_code.current_var++);
                            int size_of_args = semantic_stacks->get_args_last_func()->size();

                            gen_code.emit(declare_var_llvm(source, to_string(size_of_args), semantic_stacks->get_entry($3->get_vars()->at(i).name)->offset));
                            gen_code.emit(target + " = load i32, i32* " + source);
                            args_llvm = args_llvm + "i32 " + target + ",";
                            continue;
						}
					}
					string value = to_string($3->get_vars()->at(i).value);
                    args_llvm = args_llvm + "i32 " + value + ",";
                }
                /* Cut the last "," */
                args_llvm = args_llvm.substr(0, args_llvm.length() - 1);
                if(ret_type==TokenType::TOKEN_UNDIF)
                {
                    int index=gen_code.emit("call void @" + $1->name + "(" + args_llvm + ")");
                    gen_code.bpatch($3->false_list,to_string(index));
                    gen_code.bpatch($3->true_list,to_string(index));
                    gen_code.bpatch($3->next_list,to_string(index));
                }
                else
                {
                    string target = "%var"+to_string(gen_code.current_var++);
                    string return_type_llvm = ret_type==TokenType::TOKEN_UNDIF ? "void" : "i32";
                    gen_code.emit(target + " = call " + return_type_llvm + " @" + $1->name + "(" + args_llvm + ")");
                    if (ret_type==TokenType::TOKEN_B)
					{
						string new_target = "%var"+to_string(gen_code.current_var++);
						gen_code.emit(new_target + " = trunc i32 " + target + " to i8");
						target = new_target;
					}
					$$->place=target;
					$$->name="";
                    if (ret_type == TokenType::TOKEN_BOOL)
                    {
                        string target_boolean = "%var"+to_string(gen_code.current_var++);
                        string value = $$->place == "" ? to_string($$->value) : $$->place;
                        gen_code.emit(target_boolean + " = icmp ne i32 0, " + value);
                        int label_index = gen_code.emit("br i1 " + target_boolean + " , label @ , label @");
                        $$->true_list = gen_code.makelist({label_index, FIRST});
                        $$->false_list = gen_code.makelist({label_index, SECOND});
                    }
                }
            }
        $$->start_label = $3->start_label;
        gen_code.bpatch($$->start_list, $$->start_label);

		}
		| ID LPAREN RPAREN {
			if(!semantic_stacks->is_exsists($1->name) || !semantic_stacks->is_func($1->name))
			{
				output::errorUndefFunc(yylineno,$1->name);
				exit(2);
			}
			vector<pair<TokenType,string>>* args=semantic_stacks->get_args($1->name);
			if(args->size()!=0)
			{
				output::errorPrototypeMismatch(yylineno,$1->name, *(semantic_stacks->get_string_args($1->name)));
				exit(2);
			}
			$$ = new Call(semantic_stacks->get_type($1->name), $1->name,semantic_stacks->get_value($1->name));

            TokenType ret_type = semantic_stacks->get_func_type($1->name);
            string args_llvm = "";
                if(ret_type==TokenType::TOKEN_UNDIF)
                {
                    int index=gen_code.emit("call void @" + $1->name + "()");
                }
                  else
                {
                    //gen_code.emit("call i32 @" + $1->name + "()");
                    string target = "%var"+to_string(gen_code.current_var++);
                    string return_type_llvm = ret_type==TokenType::TOKEN_UNDIF ? "void" : "i32";
                    gen_code.emit(target + " = call " + return_type_llvm + " @" + $1->name + "()");
					if (ret_type==TokenType::TOKEN_B)
					{
						string new_target = "%var"+to_string(gen_code.current_var++);
						gen_code.emit(new_target + " = trunc i32 " + target + " to i8");
						target = new_target;
					}
                    $$->place=target;
                    $$->name="";
                    if (ret_type == TokenType::TOKEN_BOOL)
                    {
                        string target_boolean = "%var"+to_string(gen_code.current_var++);
                        string value = $$->place == "" ? to_string($$->value) : $$->place;
                        gen_code.emit(target_boolean + " = icmp ne i32 0, " + value);
                        int label_index = gen_code.emit("br i1 " + target_boolean + " , label @ , label @");
                        $$->true_list = gen_code.makelist({label_index, FIRST});
                        $$->false_list = gen_code.makelist({label_index, SECOND});
                     }
                }
            //int x = gen_code.emit("br label @");
            //std::string call_label = gen_code.genLabel();
            //gen_code.bpatch(gen_code.makelist({x, FIRST}), call_label);
            //$$->start_label = call_label;
            //gen_code.bpatch($$->start_list, $$->start_label);
		}
		;

ExpList: Exp {
			ExpList *explist = new ExpList();
			gen_code.bpatch($1->start_list, $1->start_label);
			Exp *exp= new Exp(*$1);
			gen_code.bpatch(exp->start_list, exp->start_label);
			explist->vars->push_back(*exp);
			$$ = explist;
            if ($1->type == TokenType::TOKEN_BOOL)
            {
                string target = "%var"+to_string(gen_code.current_var++);
                int unused_index = gen_code.emit("br label @");

                string true_label = gen_code.genLabel();
                gen_code.bpatch(gen_code.makelist({unused_index, FIRST}), true_label);
                int true_index = gen_code.emit("br label @");
                gen_code.bpatch($1->true_list, true_label);

                string false_label =gen_code.genLabel();
                gen_code.bpatch(gen_code.makelist({unused_index, FIRST}), false_label);
                int false_index = gen_code.emit("br label @");
                gen_code.bpatch($1->false_list, false_label);

                string next_label = gen_code.genLabel();
                gen_code.bpatch(gen_code.makelist({true_index, FIRST}), next_label);
                gen_code.bpatch(gen_code.makelist({false_index, FIRST}), next_label);
                gen_code.emit(target + " = phi i32 [ 1, %" + true_label + " ] , [ 0, %" + false_label + "]");

                $$->place = target;
            }
            $$->true_list=$1->true_list;
            $$->false_list=$1->false_list;
			$$->next_list = $1->next_list;

		}
		| ExpList COMMA Exp {
			//Exp* exp = new Exp($1->type, $1->name, $1->value);
			gen_code.bpatch($3->start_list, $3->start_label);
			Exp* exp= new Exp(*$3);
			gen_code.bpatch(exp->start_list, exp->start_label);
			$1->get_vars()->push_back(*exp);
			$$ = $1;
			if ($3->type == TokenType::TOKEN_BOOL)
            {
                string target = "%var"+to_string(gen_code.current_var++);
            std::string true_label = gen_code.genLabel();
         int loc1 = gen_code.emit("br label @");
         std::string false_label = gen_code.genLabel();
         int loc2 = gen_code.emit("br label @");

         std::string phi_label = gen_code.genLabel();
         gen_code.bpatch($3->true_list, true_label);
         gen_code.bpatch($3->false_list, false_label);
         gen_code.bpatch(gen_code.makelist({loc1, FIRST}), phi_label);
         gen_code.bpatch(gen_code.makelist({loc2, FIRST}), phi_label);

         gen_code.emit(target + " = phi i32 [1" + ", %" + true_label + "] , [0" + " , %" + false_label + "]");

                $$->place = target;
            }
            $$->true_list = gen_code.merge($1->true_list, $3->true_list);
            $$->false_list = gen_code.merge($1->false_list, $3->false_list);
			$$->next_list = gen_code.merge($1->next_list, $3->next_list);
			gen_code.bpatch($1->start_list, $1->start_label);
		}
		;

Type: INT {
		$$ = new Node(TokenType::TOKEN_INT, "", 0);
	}
	| BYTE {
		$$ = new Node(TokenType::TOKEN_B, "", 0);
	}
	| BOOL {
		$$ = new Node(TokenType::TOKEN_BOOL, "", 0);
	}
	;

Exp: LPAREN Exp RPAREN {
		$$ = new Exp($2->type, $2->name, $2->value);
		$$->true_list = $2->true_list;
		$$->false_list = $2->false_list;
		$$->break_list = $2->break_list;
		$$->continue_list = $2->continue_list;
		$$->next_list = $2->next_list;
		gen_code.bpatch($$->start_list,$$->start_label);
		$$->start_list =$2->start_list;
		$$->start_label = $2->start_label;
		$$->place = $2->place;
	}
	| Exp IF N LPAREN Exp RPAREN ELSE Exp {//trinary
		if($5->type != TokenType::TOKEN_BOOL)
		{
			output::errorMismatch(yylineno);
			exit(2);
		}
		if(convert_table[$1->type][$8->type] == TokenType::TOKEN_UNDIF)
		{
			output::errorMismatch(yylineno);
			exit(2);
		}
		
		if($5->value == 1)
			$$ = new Exp($1->type, $1->name, $1->value,true);
		else
			$$ = new Exp($8->type, $8->name, $8->value,true);


            NMarkerNode* jmp_to_end_label = new NMarkerNode();
            std::string to_start_label = gen_code.genLabel();

            NMarkerNode* middle_jmp = new NMarkerNode();
            std::string middle_label = gen_code.genLabel();

            NMarkerNode* jmp_to_bool_exp = new NMarkerNode();
            std::string end_label = gen_code.genLabelPhi();

            gen_code.bpatch($1->start_list, to_start_label);
            gen_code.bpatch($8->start_list, $8->start_label);
            gen_code.bpatch($5->true_list, $1->start_label);
            gen_code.bpatch($5->false_list, $8->start_label);
            gen_code.bpatch($5->start_list, $5->start_label);


            std::vector<pair<int, BranchLabelIndex>> all_jumps_to_end = gen_code.merge($3->next_list, jmp_to_end_label->next_list);
            gen_code.bpatch(all_jumps_to_end, end_label);
            gen_code.bpatch(jmp_to_bool_exp->next_list, $5->start_label);
            $$->place = "%var"+to_string(gen_code.current_var++);
            gen_code.bpatch($1->start_list, to_start_label);
            std::string phi_true_label = $1->trinary ? $1->start_label_trinary: $1->start_label;
            std::string phi_false_label = $8->trinary ? $8->start_label_trinary: $8->start_label;
            gen_code.emit($$->place +" = phi i32 [" + $1->place +", %" + phi_true_label + "] , [" + $8->place +  " , %" + phi_false_label+"]");
            $$->start_label_trinary = end_label;
            $$->start_label = middle_label;
            $$->start_list = gen_code.merge($$->start_list,middle_jmp->next_list);
            //$$->start_list = gen_code.merge($$->start_list,$1->start_list);
            //$$->start_list = gen_code.merge($$->start_list,$5->start_list);
            //$$->start_list = gen_code.merge($$->start_list,$8->start_list);
	}


	| Exp PLUS Exp {
		TokenType new_type;
		int new_val;
		if($1->type==TokenType::TOKEN_STRING||$1->type==TokenType::TOKEN_BOOL||$3->type==TokenType::TOKEN_STRING||$3->type==TokenType::TOKEN_BOOL)
		{
		fflush(stdout);
			output::errorMismatch(yylineno);
			exit(2);
		}
		
		if($1->type == TokenType::TOKEN_INT || $3->type == TokenType::TOKEN_INT)
			new_type = TokenType::TOKEN_INT;
		else
			new_type = TokenType::TOKEN_B;
		
		if($2->name == "+")
			new_val = $1->value + $3->value;
		else if($2->name == "-")
			new_val = $1->value - $3->value;
		$$ = new Exp(new_type, std::to_string(new_val), new_val);


		string target = "%var"+to_string(gen_code.current_var++);

        string right_place = $3->place;
        string left_place = $1->place;

        /* The values to use */
        string right = right_place == "" ? to_string($3->value) : right_place;
        string left = left_place == "" ? to_string($1->value) : left_place;

        bool can_overflow = false;
        /* Byte overflow */
        if ($1->type == TokenType::TOKEN_B && $3->type == TokenType::TOKEN_B)
		{

			string left_var = "%var"+to_string(gen_code.current_var++);
			/*
			if($1->place=="")
			{
				gen_code.emit(left_var + " = trunc i32 " + left + " to i8");
            }
            else
            {
                gen_code.emit(left_var + " = add i8 0," + left );
            }
			*/

			string right_var = "%var"+to_string(gen_code.current_var++);
			/*
			if($3->place=="")
			{
				gen_code.emit(right_var + " = trunc i32 " + right + " to i8");
            }
            else
            {
                gen_code.emit(right_var + " = add i8 0, " + right);
            }
			*/

			/* Bubble the updates */
			//left = left_var;
			//right = right_var;

			can_overflow = true;
		}

		// Fix mismatch between b and int
		if($1->type == TokenType::TOKEN_B && $3->type == TokenType::TOKEN_INT)
		{
			string new_left = "%var"+to_string(gen_code.current_var++);
			gen_code.emit(new_left + " = zext i8 " + left + " to i32");
			left = new_left;
		}
		if($1->type == TokenType::TOKEN_INT && $3->type == TokenType::TOKEN_B)
		{
			string new_right = "%var"+to_string(gen_code.current_var++);
			gen_code.emit(new_right + " = zext i8 " + right + " to i32");
			right = new_right;
		}

		string op_type_llvm = can_overflow ? "i8" : "i32";
	    if ($2->name == "+")
		{
			gen_code.emit(target + " = add " + op_type_llvm + " " + left + ", " +right);
		}
		else if ($2->name == "-")
		{
			gen_code.emit(target + " = sub " + op_type_llvm + " " + left + ", " +right);
		}

		/*
		if (can_overflow)
		{
			string next_var = "%var"+to_string(gen_code.current_var++);
			gen_code.emit(next_var + " = zext i8 " + target + " to i32");
			target = next_var;
		}
		*/

		$$->place = target;
		gen_code.bpatch($3->start_list, $3->start_label);
        $$->start_label = $1->start_label;
        gen_code.bpatch($$->start_list,$$->start_label);
        //$$->start_list =gen_code.merge($1->start_list,$$->start_list);
        $$->start_list =$1->start_list;
		$$->next_list = gen_code.merge($1->next_list,$3->next_list);
	}
	| Exp MULTI Exp  {
		TokenType new_type;
		int new_val;
		if($1->type == TokenType::TOKEN_STRING || $1->type == TokenType::TOKEN_BOOL || $3->type == TokenType::TOKEN_STRING || $3->type == TokenType::TOKEN_BOOL)
		{
			output::errorMismatch(yylineno);
			exit(2);
		}
		
		if($1->type == TokenType::TOKEN_INT || $3->type == TokenType::TOKEN_INT)
			new_type = TokenType::TOKEN_INT;
		else
			new_type = TokenType::TOKEN_B;
		
		if($2->name == "*")
			new_val = $1->value * $3->value;
		else if($2->name == "/" && $3->value != 0)
		{
			new_val = $1->value / $3->value;
		}
		$$ = new Exp(new_type, std::to_string(new_val), new_val);


        string target = "%var"+to_string(gen_code.current_var++);

        string right_place = $3->place;
        string left_place = $1->place;

        string right = right_place == "" ? to_string($3->value) : right_place;
        string left = left_place == "" ? to_string($1->value): left_place;

        bool can_overflow = false;
        if ($1->type == TokenType::TOKEN_B && $3->type == TokenType::TOKEN_B)
      	{

            string left_var = "%var"+to_string(gen_code.current_var++);
            //gen_code.emit(left_var + " = trunc i32 " + right + " to i8");

            string right_var = "%var"+to_string(gen_code.current_var++);
            //gen_code.emit(right_var + " = trunc i32 " + left + " to i8");

            /* Bubble the updates */
            //left = left_var;
            //right = right_var;

            can_overflow = true;
        }

		// Fix mismatch between b and int
		if($1->type == TokenType::TOKEN_B && $3->type == TokenType::TOKEN_INT)
		{
			string new_left = "%var"+to_string(gen_code.current_var++);
			gen_code.emit(new_left + " = zext i8 " + left + " to i32");
			left = new_left;
		}
		if($1->type == TokenType::TOKEN_INT && $3->type == TokenType::TOKEN_B)
		{
			string new_right = "%var"+to_string(gen_code.current_var++);
			gen_code.emit(new_right + " = zext i8 " + right + " to i32");
			right = new_right;
		}
		string llvm_op;
        if ($$->type==TokenType::TOKEN_INT){
            llvm_op = "sdiv";
        }else if ($$->type==TokenType::TOKEN_B){
            llvm_op = "udiv";
        }

        string op_type_llvm = can_overflow ? "i8" : "i32";

        if ($2->name == "/")
        {
        	string zero_var_llvm = "%var"+to_string(gen_code.current_var++);
            string zero_source = right == "" ? to_string($3->value) : right;

            gen_code.emit(zero_var_llvm + " = icmp eq "+ op_type_llvm + " " + zero_source + ", 0");
            int zero_bp = gen_code.emit("br i1 " + zero_var_llvm + " , label @ , label @");

            string error_label = gen_code.genLabel();
            gen_code.emit("call i32 (i8*, ...) @printf(i8* getelementptr([24 x i8], [24 x i8]* @.zero_div, i32 0, i32 0))");
            gen_code.emit("call void @exit(i32 0)");

            int unused_bp = gen_code.emit("br label @");

            string success_label = gen_code.genLabel();
            gen_code.emit(target + " = "+ llvm_op + " " + op_type_llvm + " " + left+ ", "+ right);
            gen_code.bpatch(gen_code.makelist({zero_bp, SECOND}), success_label);
            gen_code.bpatch(gen_code.makelist({zero_bp, FIRST}), error_label);
            gen_code.bpatch(gen_code.makelist({unused_bp, FIRST}), success_label);
        }
        else if ($2->name == "*")
        {
            gen_code.emit(target + " = mul " + op_type_llvm+ " "+ left+ ", " +right);
        }

        /* Handle overflow / sign */
		/*
        if (can_overflow)
        {
            string next_var = "%var"+to_string(gen_code.current_var++);
            gen_code.emit(next_var + " = zext i8 " + target + " to i32");
            target = next_var;
        }
		*/

		$$->place = target;
		gen_code.bpatch($3->start_list, $3->start_label);
		$$->start_label = $1->start_label;
		gen_code.bpatch($$->start_list,$$->start_label);
		$$->start_list =$1->start_list;
		//$$->start_list =gen_code.merge($1->start_list,$$->start_list);
		$$->next_list = gen_code.merge($1->next_list,$3->next_list);
        }
	| ID  {

		if(semantic_stacks->is_func($1->name))
		{
			output::errorUndef(yylineno,$1->name);
			exit(2);
		}

		TokenType type = semantic_stacks->get_type($1->name);
		
		if(TOKEN_UNDIF==type)
		{
			output::errorUndef(yylineno, $1->name);
			exit(2);
		}

		$$ = new Exp(type, $1->name, semantic_stacks->get_value($1->name));
        string source = "%var"+to_string(gen_code.current_var++);
        string target = "%var"+to_string(gen_code.current_var++);

        int size_of_args = semantic_stacks->get_args_last_func()->size();

        table_entry * entry=semantic_stacks->get_entry($1->name);

        gen_code.emit(declare_var_llvm(source, to_string(size_of_args), entry->offset));
        gen_code.emit(target + " = load i32, i32* " + source);
        $$->place = target;

        string new_var = "%var"+to_string(gen_code.current_var++);
        if(entry->type==TokenType::TOKEN_B)
        {
            gen_code.emit(new_var + " = trunc i32 " + target + " to i8");
            $$->place = new_var;
        }
        if(entry->offset>=0)
		{
			int loc = gen_code.emit("br label @");
			$$->start_label = gen_code.genLabel();
			//$$->start_list = gen_code.merge(gen_code.makelist({loc, FIRST}),$$->start_list);

			$$->start_list = gen_code.makelist({loc, FIRST});

		}
		if (entry->type == TokenType::TOKEN_BOOL)
		{
			if (entry->offset<0)
			{
				int loc = gen_code.emit("br label @");
				$$->start_label = gen_code.genLabel();
				//$$->start_list =gen_code.merge(gen_code.makelist({loc, FIRST}),$$->start_list);
				$$->start_list = gen_code.makelist({loc, FIRST});
			}
		string target_boolean = "%var"+to_string(gen_code.current_var++);
		string value = $$->place == "" ? to_string($$->value) : $$->place;
		gen_code.emit(target_boolean + " = icmp ne i32 0, " + value);
		int branch_index = gen_code.emit("br i1 " + target_boolean + " , label @ , label @");
		auto unconditional_list = gen_code.makelist({branch_index, FIRST});
		auto conditional_list = gen_code.makelist({branch_index, SECOND});
		$$->true_list = unconditional_list;
		$$->false_list = conditional_list;
        gen_code.bpatch($$->start_list, $$->start_label);
		}


	}
	| Call {$$ = $1;}
	| NUM {
		$$->type = $1->type;
        $$->value = $1->value;
	}
	| NUM B {
		$$->type = TokenType::TOKEN_B;
      	$$->value = $1->value;
      	if ($1->value > 255)
		{
        	output::errorByteTooLarge(yylineno, std::to_string($1->value)); 
			exit(2);
		}
	}
	| STRING {
		$$ = new Exp($1->type, $1->name, $1->value);

		string str_full_value = $1->name;
		string str_value = str_full_value.substr(1, str_full_value.length() - 2);
		$$->place = "@.str_" + to_string(gen_code.current_var++);
		string str_len = to_string(str_value.length() + 1);
		gen_code.emitGlobal($$->place + " = constant [" + str_len + " x i8] c\"" + str_value + "\\00\"");
		gen_code.bpatch($$->start_list, $$->start_label);
	}
	| TRUE  {
		$$ = new Exp(TokenType::TOKEN_BOOL, "TRUE",1);
		int label_index = gen_code.emit("br label @");
        $$->true_list = gen_code.makelist({label_index, FIRST});
        gen_code.bpatch($$->start_list, $$->start_label);
	}
	| FALSE  {
		$$ = new Exp(TokenType::TOKEN_BOOL, "FALSE",0);
		int label_index = gen_code.emit("br label @");
        $$->false_list = gen_code.makelist({label_index, FIRST});
        gen_code.bpatch($$->start_list, $$->start_label);
	}
	| NOT Exp  {
		if($2->value == 0)
			$$ = new Exp($2->type, "TRUE", 1);
		else 
			$$ = new Exp($2->type, "FALSE", 0);
		//string flippedBool = "%var"+to_string(gen_code.current_var++);
        //string newPlace = "%var"+to_string(gen_code.current_var++);
		//string value = $2->place == "" ? to_string($2->value) : $2->place;
        //gen_code.emit(flippedBool + " = icmp ne i32 1, " + value);
        //gen_code.emit(newPlace + "= zext i1 " + flippedBool + " to i32");
        //$$->place=$2->place;
        $$->true_list=$2->false_list;
        $$->false_list=$2->true_list;
		$$->next_list = $2->next_list;
		gen_code.bpatch($$->start_list,$$->start_label);
		//$$->start_list = gen_code.merge($2->start_list,$$->start_list);
		$$->start_list= $2->start_list;
		$$->start_label = $2->start_label;
	}
	| Exp AND M Exp  {
		if($1->type != TokenType::TOKEN_BOOL || $4->type != TokenType::TOKEN_BOOL)
		{
			output::errorMismatch(yylineno);
			exit(2);
		}

		int new_val = $1->value & $4->value;
		if(new_val == 0)
			$$ = new Exp($1->type, "FALSE", new_val);
		else 
			$$ = new Exp($1->type, "TRUE", new_val);
		$$->quad=$3->quad;
		gen_code.bpatch($1->true_list, $$->quad);
        $$->true_list = $4->true_list;
        $$->false_list = gen_code.merge($1->false_list, $4->false_list);
        gen_code.bpatch($4->start_list, $4->start_label);
        $$->start_label = $1->start_label;
        gen_code.bpatch($$->start_list, $$->start_label);
        //$$->start_list =gen_code.merge($1->start_list,$$->start_list);
        $$->start_list=$1->start_list;
		}
		| Exp OR M Exp  {
			if($1->type != TokenType::TOKEN_BOOL || $4->type != TokenType::TOKEN_BOOL)
			{
				output::errorMismatch(yylineno);
				exit(2);
			}
			
			int new_val = $1->value | $4->value;
			if(new_val == 0) 
				$$ = new Exp($1->type, "FALSE", new_val);
			else 
				$$ = new Exp($1->type, "TRUE", new_val);
			$$->quad=$3->quad;
			gen_code.bpatch($1->false_list, $$->quad);
            $$->false_list = $4->false_list;
            $$->true_list = gen_code.merge($1->true_list, $4->true_list);
            gen_code.bpatch($4->start_list, $4->start_label);
            $$->start_label = $1->start_label;
            gen_code.bpatch($$->start_list, $$->start_label);
            //$$->start_list =gen_code.merge($1->start_list,$$->start_list);
            $$->start_list =$1->start_list;
			$$->next_list = gen_code.merge($1->next_list,$4->next_list);
		}		
		| Exp RELOP Exp  {
			//Mismatch check
			if($1->type == TokenType::TOKEN_UNDIF || $1->type == TokenType::TOKEN_BOOL || $1->type == TokenType::TOKEN_STRING ||
				$3->type == TokenType::TOKEN_UNDIF || $3->type == TokenType::TOKEN_STRING || $3->type == TokenType::TOKEN_BOOL)
			{
			    fflush(stdout);
				output::errorMismatch(yylineno);
				exit(2);
			}

			//Value update
			int new_val;
			if($2->name == "==")
				new_val = $1->value == $3->value;
			if($2->name == "!=")
				new_val = $1->value != $3->value;
			if($2->name == "<")
				new_val = $1->value < $3->value;
			if($2->name == ">")
				new_val = $1->value > $3->value;
			if($2->name == "<=")
				new_val = $1->value <= $3->value;
			if($2->name == ">=")
				new_val = $1->value >= $3->value;

			if(new_val == 1) 
				$$ = new Exp(TokenType::TOKEN_BOOL, "TRUE", new_val);
			else 
				$$ = new Exp(TokenType::TOKEN_BOOL, "FALSE", new_val);

			string right_value = to_string($3->value);
            string left_value = to_string($1->value);

            /* The values to use */
    		string right = $3->place == "" ? right_value : $3->place;
            string left = $1->place == "" ? left_value : $1->place;
            string op_llvm = "eq"; /* == */

            if ($2->name == ">")
            {
            	op_llvm = "sgt";
            }
            else if ($2->name == ">=")
            {
                op_llvm = "sge";
            }
            else if ($2->name == "<")
            {
                op_llvm = "slt";
            }
            else if ($2->name == "<=")
            {
                op_llvm = "sle";
            }
            else if ($2->name == "!=")
            {
                op_llvm = "ne";
            }

			if($1->type == TokenType::TOKEN_B && $1->place != "")
			{
				left = "%var"+to_string(gen_code.current_var++);
				gen_code.emit(left + " = zext i8 " + $1->place + " to i32");
            }
			if($3->type == TokenType::TOKEN_B && $3->place != "")
			{
				right = "%var"+to_string(gen_code.current_var++);
				gen_code.emit(right + " = zext i8 " + $3->place + " to i32");
            }

            string target = "%var"+to_string(gen_code.current_var++);
            string finalRes = "%var"+to_string(gen_code.current_var++);
            gen_code.emit(target + " = icmp " + op_llvm + " i32 " + left + ", " + right);

			gen_code.emit(finalRes + " = zext i1 " + target + " to i32");
            int label_index = gen_code.emit("br i1 " + target + " , label @ , label @");

            $$->true_list = gen_code.makelist({label_index, FIRST});
            $$->false_list = gen_code.makelist({label_index, SECOND});
            $$->place = finalRes;
            gen_code.bpatch($3->start_list, $3->start_label);
            $$->start_label = $1->start_label;
            gen_code.bpatch($$->start_list, $$->start_label);
            //$$->start_list =gen_code.merge($1->start_list,$$->start_list);
            $$->start_list =$1->start_list;
			$$->next_list = gen_code.merge($1->next_list,$3->next_list);
	}
	| LPAREN Type RPAREN Exp %prec CAST   {
		if(convert_table[$2->type][$4->type] == TokenType::TOKEN_UNDIF)
		{
			output::errorMismatch(yylineno);
			exit(2);
		}
		if($2->type == TokenType::TOKEN_BOOL) 
			{
			    $$ = $4;
			}
		if($2->type == TokenType::TOKEN_INT)
			{
			    $$ = new Exp($2->type,$4->name,$4->value);
			    if($4->type==TokenType::TOKEN_B)
			    {
			         string next_var = "%var"+to_string(gen_code.current_var++);
					 string target = $4->place == "" ? to_string($4->value) : $4->place;
                     gen_code.emit(next_var + " = zext i8 " + target + " to i32");//not sure if neccesery test yosnkos15
                     $$->place = next_var;
			    }
			}
		if($2->type == TokenType::TOKEN_B)
		{
			if($4->type == TokenType::TOKEN_INT && $4->value > 255) 
			{
				//output::errorByteTooLarge(yylineno, std::to_string($4->value));
				//exit(2);
			}
			$$ = new Exp($2->type,$4->name,$4->value);
			string next_var = "%var"+to_string(gen_code.current_var++);
			auto target = $4->place == "" ? to_string($4->value) : $4->place;
			gen_code.emit(next_var + " = trunc i32 " + target + " to i8");
			//string next_next_var = "%var"+to_string(gen_code.current_var++);
			//gen_code.emit(next_next_var + " = zext i8 " + next_var + " to i32");
			$$->place = next_var;
			$$->name="";
		}
		$$->next_list = $4->next_list;
		gen_code.bpatch($$->start_list, $$->start_label);
		$$->start_list =$4->start_list;
        $$->start_label = $4->start_label;
	}
	;


%%

int yyerror(const char* const s)
{
  extern int yylineno;
  output::errorSyn(yylineno);
  exit(2);
}

int main(){
//yydebug=1;

     int ret= yyparse();
	gen_code.emitGlobal(printf_llvm);
    gen_code.emitGlobal(zero_div_llvm);
    gen_code.emitGlobal(printi_llvm);

    gen_code.emitGlobal(print_llvm);
    gen_code.emitGlobal(exit_llvm);

    gen_code.printGlobalBuffer();
    gen_code.printCodeBuffer();
    return ret;
}

